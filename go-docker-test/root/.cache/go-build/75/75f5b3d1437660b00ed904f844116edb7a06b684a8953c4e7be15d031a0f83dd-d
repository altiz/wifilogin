// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/rows.go:1:1
// Copyright 2017 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"bytes"
	"database/sql/driver"
	"fmt"
	"io"
	"math"
	"reflect"
	"strconv"
	"time"
	"unsafe"

	errors "golang.org/x/xerrors"
)

var _ = driver.Rows((*rows)(nil))
var _ = driver.RowsColumnTypeDatabaseTypeName((*rows)(nil))
var _ = driver.RowsColumnTypeLength((*rows)(nil))
var _ = driver.RowsColumnTypeNullable((*rows)(nil))
var _ = driver.RowsColumnTypePrecisionScale((*rows)(nil))
var _ = driver.RowsColumnTypeScanType((*rows)(nil))
var _ = driver.RowsNextResultSet((*rows)(nil))

type rows struct {
	columns   []Column
	vars      []* /*line :36:15*/_Ctype_dpiVar /*line :36:23*/
	data      [][] /*line :37:16*/_Ctype_dpiData /*line :37:25*/
	err       error
	nextRsErr error
	*statement
	origSt         *statement
	nextRs         * /*line :42:18*/_Ctype_dpiStmt /*line :42:27*/
	bufferRowIndex  /*line :43:17*/_Ctype_uint32_t /*line :43:27*/
	fetched         /*line :44:17*/_Ctype_uint32_t /*line :44:27*/
	finished       bool
}

// Columns returns the names of the columns. The number of
// columns of the result is inferred from the length of the
// slice. If a particular column name isn't known, an empty
// string should be returned for that entry.
func (r *rows) Columns() []string {
	names := make([]string, len(r.columns))
	for i, col := range r.columns {
		names[i] = col.Name
	}
	return names
}

// Close closes the rows iterator.
func (r *rows) Close() error {
	if r == nil {
		return nil
	}
	vars, st := r.vars, r.statement
	r.columns, r.vars, r.data, r.statement, r.nextRs = nil, nil, nil, nil, nil
	for _, v := range vars[:cap(vars)] {
		if v != nil {
			func() _Ctype_int{ _cgo0 := /*line :69:21*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_release(_cgo0); }()
		}
	}
	if st == nil {
		return nil
	}

	st.Lock()
	defer st.Unlock()
	if st.dpiStmt == nil {
		return nil
	}
	var err error
	if func() _Ctype_int{ _cgo0 := /*line :82:23*/st.dpiStmt; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_release(_cgo0); }() == ( /*line :82:38*/_Ciconst_DPI_FAILURE /*line :82:50*/) {
		err = errors.Errorf("rows/dpiStmt_release: %w", r.getError())
	}
	return err
}

// ColumnTypeLength return the length of the column type if the column is a variable length type.
// If the column is not a variable length type ok should return false.
// If length is not limited other than system limits, it should return math.MaxInt64.
// The following are examples of returned values for various types:
//
// TEXT          (math.MaxInt64, true)
// varchar(10)   (10, true)
// nvarchar(10)  (10, true)
// decimal       (0, false)
// int           (0, false)
// bytea(30)     (30, true)
func (r *rows) ColumnTypeLength(index int) (length int64, ok bool) {
	switch col := r.columns[index]; col.OracleType {
	case ( /*line :101:7*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :101:31*/), ( /*line :101:34*/_Ciconst_DPI_ORACLE_TYPE_NVARCHAR /*line :101:59*/),
		( /*line :102:3*/_Ciconst_DPI_ORACLE_TYPE_CHAR /*line :102:24*/), ( /*line :102:27*/_Ciconst_DPI_ORACLE_TYPE_NCHAR /*line :102:49*/),
		( /*line :103:3*/_Ciconst_DPI_ORACLE_TYPE_LONG_VARCHAR /*line :103:32*/),
		( /*line :104:3*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :104:25*/):
		return int64(col.Size), true
	case ( /*line :106:7*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :106:28*/), ( /*line :106:31*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :106:53*/),
		( /*line :107:3*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :107:24*/),
		( /*line :108:3*/_Ciconst_DPI_ORACLE_TYPE_BFILE /*line :108:25*/),
		( /*line :109:3*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :109:23*/):
		return math.MaxInt64, true
	default:
		return 0, false
	}
}

// ColumnTypeDatabaseTypeName returns the database system type name without the length.
// Type names should be uppercase.
// Examples of returned types: "VARCHAR", "NVARCHAR", "VARCHAR2", "CHAR", "TEXT", "DECIMAL", "SMALLINT", "INT", "BIGINT", "BOOL", "[]BIGINT", "JSONB", "XML", "TIMESTAMP".
func (r *rows) ColumnTypeDatabaseTypeName(index int) string {
	switch r.columns[index].OracleType {
	case ( /*line :121:7*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :121:31*/):
		return "VARCHAR2"
	case ( /*line :123:7*/_Ciconst_DPI_ORACLE_TYPE_NVARCHAR /*line :123:32*/):
		return "NVARCHAR2"
	case ( /*line :125:7*/_Ciconst_DPI_ORACLE_TYPE_CHAR /*line :125:28*/):
		return "CHAR"
	case ( /*line :127:7*/_Ciconst_DPI_ORACLE_TYPE_NCHAR /*line :127:29*/):
		return "NCHAR"
	case ( /*line :129:7*/_Ciconst_DPI_ORACLE_TYPE_LONG_VARCHAR /*line :129:36*/):
		return "LONG"
	case ( /*line :131:7*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :131:29*/), ( /*line :131:32*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :131:52*/):
		return "RAW"
	case ( /*line :133:7*/_Ciconst_DPI_ORACLE_TYPE_ROWID /*line :133:29*/), ( /*line :133:32*/_Ciconst_DPI_NATIVE_TYPE_ROWID /*line :133:54*/):
		return "ROWID"
	case ( /*line :135:7*/_Ciconst_DPI_ORACLE_TYPE_LONG_RAW /*line :135:32*/):
		return "LONG RAW"
	case ( /*line :137:7*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :137:30*/):
		return "NUMBER"
	case ( /*line :139:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :139:36*/), ( /*line :139:39*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :139:61*/):
		return "FLOAT"
	case ( /*line :141:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :141:37*/), ( /*line :141:40*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :141:63*/):
		return "DOUBLE"
	case ( /*line :143:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :143:34*/), ( /*line :143:37*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :143:59*/):
		return "BINARY_INTEGER"
	case ( /*line :145:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :145:35*/), ( /*line :145:38*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :145:61*/):
		return "BINARY_INTEGER"
	case ( /*line :147:7*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP /*line :147:33*/), ( /*line :147:36*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :147:62*/):
		return "TIMESTAMP"
	case ( /*line :149:7*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_TZ /*line :149:36*/):
		return "TIMESTAMP WITH TIMEZONE"
	case ( /*line :151:7*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_LTZ /*line :151:37*/):
		return "TIMESTAMP WITH LOCAL TIMEZONE"
	case ( /*line :153:7*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :153:28*/):
		return "DATE"
	case ( /*line :155:7*/_Ciconst_DPI_ORACLE_TYPE_INTERVAL_DS /*line :155:35*/), ( /*line :155:38*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :155:66*/):
		return "INTERVAL DAY TO SECOND"
	case ( /*line :157:7*/_Ciconst_DPI_ORACLE_TYPE_INTERVAL_YM /*line :157:35*/), ( /*line :157:38*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :157:66*/):
		return "INTERVAL YEAR TO MONTH"
	case ( /*line :159:7*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :159:28*/):
		return "CLOB"
	case ( /*line :161:7*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :161:29*/):
		return "NCLOB"
	case ( /*line :163:7*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :163:28*/):
		return "BLOB"
	case ( /*line :165:7*/_Ciconst_DPI_ORACLE_TYPE_BFILE /*line :165:29*/):
		return "BFILE"
	case ( /*line :167:7*/_Ciconst_DPI_ORACLE_TYPE_STMT /*line :167:28*/), ( /*line :167:31*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :167:52*/):
		return "SYS_REFCURSOR"
	case ( /*line :169:7*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :169:31*/), ( /*line :169:34*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :169:58*/):
		return "BOOLEAN"
	case ( /*line :171:7*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :171:30*/):
		return "OBJECT"
	default:
		return fmt.Sprintf("OTHER[%d]", r.columns[index].OracleType)
	}
}

// ColumnTypeNullable. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.

func (r *rows) ColumnTypeNullable(index int) (nullable, ok bool) {
	return r.columns[index].Nullable, true
}

// ColumnTypePrecisionScale returns the precision and scale for decimal types.
// If not applicable, ok should be false.
// The following are examples of returned values for various types:
//
// decimal(38, 4)    (38, 4, true)
// int               (0, 0, false)
// decimal           (math.MaxInt64, math.MaxInt64, true)
func (r *rows) ColumnTypePrecisionScale(index int) (precision, scale int64, ok bool) {
	switch col := r.columns[index]; col.OracleType {
	case
		//C.DPI_ORACLE_TYPE_NATIVE_FLOAT, C.DPI_NATIVE_TYPE_FLOAT,
		//C.DPI_ORACLE_TYPE_NATIVE_DOUBLE, C.DPI_NATIVE_TYPE_DOUBLE,
		//C.DPI_ORACLE_TYPE_NATIVE_INT, C.DPI_NATIVE_TYPE_INT64,
		//C.DPI_ORACLE_TYPE_NATIVE_UINT, C.DPI_NATIVE_TYPE_UINT64,
		( /*line :198:3*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :198:26*/):
		return int64(col.Precision), int64(col.Scale), true
	default:
		return 0, 0, false
	}
}

// ColumnTypeScanType returns the value type that can be used to scan types into.
// For example, the database column type "bigint" this should return "reflect.TypeOf(int64(0))".
func (r *rows) ColumnTypeScanType(index int) reflect.Type {
	switch col := r.columns[index]; col.OracleType {
	case ( /*line :209:7*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :209:29*/), ( /*line :209:32*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :209:52*/),
		( /*line :210:3*/_Ciconst_DPI_ORACLE_TYPE_ROWID /*line :210:25*/), ( /*line :210:28*/_Ciconst_DPI_NATIVE_TYPE_ROWID /*line :210:50*/),
		( /*line :211:3*/_Ciconst_DPI_ORACLE_TYPE_LONG_RAW /*line :211:28*/):
		return reflect.TypeOf([]byte(nil))
	case ( /*line :213:7*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :213:30*/):
		switch col.NativeType {
		case ( /*line :215:8*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :215:30*/):
			return reflect.TypeOf(int64(0))
		case ( /*line :217:8*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :217:31*/):
			return reflect.TypeOf(uint64(0))
		//case C.DPI_NATIVE_TYPE_FLOAT:
		//	return reflect.TypeOf(float32(0))
		//case C.DPI_NATIVE_TYPE_DOUBLE:
		//		return reflect.TypeOf(float64(0))
		default:
			return reflect.TypeOf(Number(""))
		}
	case ( /*line :226:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :226:36*/), ( /*line :226:39*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :226:61*/):
		return reflect.TypeOf(float32(0))
	case ( /*line :228:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :228:37*/), ( /*line :228:40*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :228:63*/):
		return reflect.TypeOf(float64(0))
	case ( /*line :230:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :230:34*/), ( /*line :230:37*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :230:59*/):
		return reflect.TypeOf(int64(0))
	case ( /*line :232:7*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :232:35*/), ( /*line :232:38*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :232:61*/):
		return reflect.TypeOf(uint64(0))
	case ( /*line :234:7*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP /*line :234:33*/), ( /*line :234:36*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :234:62*/),
		( /*line :235:3*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_TZ /*line :235:32*/), ( /*line :235:35*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_LTZ /*line :235:65*/),
		( /*line :236:3*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :236:24*/):
		return reflect.TypeOf(time.Time{})
	case ( /*line :238:7*/_Ciconst_DPI_ORACLE_TYPE_INTERVAL_DS /*line :238:35*/), ( /*line :238:38*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :238:66*/):
		return reflect.TypeOf(time.Duration(0))
	case ( /*line :240:7*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :240:28*/), ( /*line :240:31*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :240:53*/):
		return reflect.TypeOf("")
	case ( /*line :242:7*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :242:28*/), ( /*line :242:31*/_Ciconst_DPI_ORACLE_TYPE_BFILE /*line :242:53*/):
		return reflect.TypeOf([]byte(nil))
	case ( /*line :244:7*/_Ciconst_DPI_ORACLE_TYPE_STMT /*line :244:28*/), ( /*line :244:31*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :244:52*/):
		return reflect.TypeOf(&statement{})
	case ( /*line :246:7*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :246:31*/), ( /*line :246:34*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :246:58*/):
		return reflect.TypeOf(false)
	default:
		return reflect.TypeOf("")
	}
}

// Next is called to populate the next row of data into
// the provided slice. The provided slice will be the same
// size as the Columns() are wide.
//
// Next should return io.EOF when there are no more rows.
//
// As with all Objects, you MUST call Close on the returned Object instances when they're not needed anymore!
func (r *rows) Next(dest []driver.Value) error {
	if r.err != nil {
		return r.err
	}
	if r.finished {
		_ = r.Close()
		return io.EOF
	}
	if len(dest) != len(r.columns) {
		return errors.Errorf("column count mismatch: we have %d columns, but given %d destination", len(r.columns), len(dest))
	}
	if r.fetched == 0 {
		var moreRows  /*line :272:16*/_Ctype_int /*line :272:21*/
		if func() _Ctype_int{ _cgo0 := /*line :273:26*/r.dpiStmt; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(r.statement.FetchRowCount()); var _cgo2 *_Ctype_uint32_t = /*line :273:78*/&r.bufferRowIndex; var _cgo3 *_Ctype_uint32_t = /*line :273:97*/&r.fetched; var _cgo4 *_Ctype_int = /*line :273:109*/&moreRows; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_fetchRows(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == ( /*line :273:123*/_Ciconst_DPI_FAILURE /*line :273:135*/) {
			return errors.Errorf("Next: %w", r.getError())
		}
		if Log != nil {
			Log("msg", "fetched", "bri", r.bufferRowIndex, "fetched", r.fetched, "moreRows", moreRows, "len(data)", len(r.data), "cols", len(r.columns))
		}
		if r.fetched == 0 {
			r.finished = moreRows == 0
			_ = r.Close()
			return io.EOF
		}
		if r.data == nil {
			r.data = make([][] /*line :285:22*/_Ctype_dpiData /*line :285:31*/, len(r.columns))
			for i := range r.columns {
				var n  /*line :287:11*/_Ctype_uint32_t /*line :287:21*/
				var data * /*line :288:15*/_Ctype_dpiData /*line :288:24*/
				if func() _Ctype_int{ _cgo0 := /*line :289:33*/r.vars[i]; var _cgo1 _Ctype_uint32_t = /*line :289:44*/0; var _cgo2 *_Ctype_uint32_t = /*line :289:47*/&n; _cgoBase3 := /*line :289:51*/&data; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return _Cfunc_dpiVar_getReturnedData(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :289:61*/_Ciconst_DPI_FAILURE /*line :289:73*/) {
					return errors.Errorf("getReturnedData[%d]: %w", i, r.getError())
				}
				r.data[i] = (*[maxArraySize] /*line :292:33*/_Ctype_dpiData /*line :292:42*/)(unsafe.Pointer(data))[:n:n]
				//fmt.Printf("data %d=%+v\n%+v\n", n, data, r.data[i][0])
			}
		}

	}
	//fmt.Printf("data=%#v\n", r.data)

	//fmt.Printf("bri=%d fetched=%d\n", r.bufferRowIndex, r.fetched)
	//fmt.Printf("data=%#v\n", r.data[0][r.bufferRowIndex])
	//fmt.Printf("VC=%d\n", C.DPI_ORACLE_TYPE_VARCHAR)
	for i, col := range r.columns {
		typ := col.OracleType
		d := &r.data[i][r.bufferRowIndex]
		isNull := d.isNull == 1
		if false && Log != nil {
			Log("msg", "Next", "i", i, "row", r.bufferRowIndex, "typ", typ, "null", isNull) //, "data", fmt.Sprintf("%+v", d), "typ", typ)
		}

		switch typ {
		case ( /*line :312:8*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :312:32*/), ( /*line :312:35*/_Ciconst_DPI_ORACLE_TYPE_NVARCHAR /*line :312:60*/),
			( /*line :313:4*/_Ciconst_DPI_ORACLE_TYPE_CHAR /*line :313:25*/), ( /*line :313:28*/_Ciconst_DPI_ORACLE_TYPE_NCHAR /*line :313:50*/),
			( /*line :314:4*/_Ciconst_DPI_ORACLE_TYPE_LONG_VARCHAR /*line :314:33*/):
			//fmt.Printf("CHAR\n")
			if isNull {
				dest[i] = ""
				continue
			}
			b := ( /*line :320:9*/_Cfunc_dpiData_getBytes /*line :320:26*/)(d)
			if b.length == 0 {
				dest[i] = ""
				continue
			}
			dest[i] = ( /*line :325:14*/_Cfunc_GoStringN /*line :325:24*/)(b.ptr,  /*line :325:33*/_Ctype_int /*line :325:38*/(b.length))

		case ( /*line :327:8*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :327:31*/):
			if isNull {
				//if Log != nil { Log("msg", "null", "i", i, "T", fmt.Sprintf("%T", dest[i]), "type", reflect.TypeOf(dest[i])) }
				dest[i] = nil
				continue
			}
			switch col.NativeType {
			case ( /*line :334:9*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :334:31*/):
				dest[i] = int64(( /*line :335:21*/_Cfunc_dpiData_getInt64 /*line :335:38*/)(d))
			case ( /*line :336:9*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :336:32*/):
				dest[i] = uint64(( /*line :337:22*/_Cfunc_dpiData_getUint64 /*line :337:40*/)(d))
			case ( /*line :338:9*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :338:31*/):
				//dest[i] = float32(C.dpiData_getFloat(d))
				dest[i] = printFloat(float64(( /*line :340:34*/_Cfunc_dpiData_getFloat /*line :340:51*/)(d)))
			case ( /*line :341:9*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :341:32*/):
				//dest[i] = float64(C.dpiData_getDouble(d))
				dest[i] = printFloat(float64(( /*line :343:34*/_Cfunc_dpiData_getDouble /*line :343:52*/)(d)))
			default:
				b := ( /*line :345:10*/_Cfunc_dpiData_getBytes /*line :345:27*/)(d)
				s := ( /*line :346:10*/_Cfunc_GoStringN /*line :346:20*/)(b.ptr,  /*line :346:29*/_Ctype_int /*line :346:34*/(b.length))
				if r.NumberAsString() {
					dest[i] = s
				} else {
					dest[i] = Number(s)
				}
				if Log != nil {
					Log("msg", "b", "i", i, "ptr", b.ptr, "length", b.length, "typ", col.NativeType, "int64", ( /*line :353:96*/_Cfunc_dpiData_getInt64 /*line :353:113*/)(d), "dest", dest[i])
				}
			}
			if Log != nil {
				Log("msg", "num", "t", col.NativeType, "i", i, "dest", fmt.Sprintf("%T %+v", dest[i], dest[i]))
			}

		case ( /*line :360:8*/_Ciconst_DPI_ORACLE_TYPE_ROWID /*line :360:30*/), ( /*line :360:33*/_Ciconst_DPI_NATIVE_TYPE_ROWID /*line :360:55*/),
			( /*line :361:4*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :361:24*/), ( /*line :361:27*/_Ciconst_DPI_ORACLE_TYPE_LONG_RAW /*line :361:52*/):
			if isNull {
				dest[i] = nil
				continue
			}
			b := ( /*line :366:9*/_Cfunc_dpiData_getBytes /*line :366:26*/)(d)
			if b.length == 0 {
				dest[i] = []byte{}
				continue
			}
			dest[i] = func() []byte{ _cgo0 := /*line :371:24*/unsafe.Pointer(b.ptr); var _cgo1 _Ctype_int = _Ctype_int(b.length); _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()
		case ( /*line :372:8*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :372:37*/), ( /*line :372:40*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :372:62*/):
			if isNull {
				dest[i] = nil
				continue
			}
			dest[i] = float32(( /*line :377:22*/_Cfunc_dpiData_getFloat /*line :377:39*/)(d))
		case ( /*line :378:8*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :378:38*/), ( /*line :378:41*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :378:64*/):
			if isNull {
				dest[i] = nil
				continue
			}
			dest[i] = float64(( /*line :383:22*/_Cfunc_dpiData_getDouble /*line :383:40*/)(d))
		case ( /*line :384:8*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :384:35*/), ( /*line :384:38*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :384:60*/):
			if isNull {
				dest[i] = nil
				continue
			}
			dest[i] = int64(( /*line :389:20*/_Cfunc_dpiData_getInt64 /*line :389:37*/)(d))
		case ( /*line :390:8*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :390:36*/), ( /*line :390:39*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :390:62*/):
			if isNull {
				dest[i] = nil
				continue
			}
			dest[i] = uint64(( /*line :395:21*/_Cfunc_dpiData_getUint64 /*line :395:39*/)(d))
		case ( /*line :396:8*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP /*line :396:34*/),
			( /*line :397:4*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_TZ /*line :397:33*/), ( /*line :397:36*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP_LTZ /*line :397:66*/),
			( /*line :398:4*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :398:30*/),
			( /*line :399:4*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :399:25*/):
			if isNull {
				dest[i] = time.Time{}
				continue
			}
			ts := ( /*line :404:10*/_Cfunc_dpiData_getTimestamp /*line :404:31*/)(d)
			tz := r.conn.timeZone
			if col.OracleType != ( /*line :406:25*/_Ciconst_DPI_ORACLE_TYPE_TIMESTAMP /*line :406:51*/) && col.OracleType != ( /*line :406:74*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :406:95*/) {
				tz = timeZoneFor(ts.tzHourOffset, ts.tzMinuteOffset)
			}
			dest[i] = time.Date(int(ts.year), time.Month(ts.month), int(ts.day), int(ts.hour), int(ts.minute), int(ts.second), int(ts.fsecond), tz)
		case ( /*line :410:8*/_Ciconst_DPI_ORACLE_TYPE_INTERVAL_DS /*line :410:36*/), ( /*line :410:39*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :410:67*/):
			if isNull {
				dest[i] = nil
				continue
			}
			ds := ( /*line :415:10*/_Cfunc_dpiData_getIntervalDS /*line :415:32*/)(d)
			dest[i] = time.Duration(ds.days)*24*time.Hour +
				time.Duration(ds.hours)*time.Hour +
				time.Duration(ds.minutes)*time.Minute +
				time.Duration(ds.seconds)*time.Second +
				time.Duration(ds.fseconds)
		case ( /*line :421:8*/_Ciconst_DPI_ORACLE_TYPE_INTERVAL_YM /*line :421:36*/), ( /*line :421:39*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :421:67*/):
			if isNull {
				dest[i] = nil
				continue
			}
			ym := ( /*line :426:10*/_Cfunc_dpiData_getIntervalYM /*line :426:32*/)(d)
			dest[i] = fmt.Sprintf("%dy%dm", ym.years, ym.months)

		case ( /*line :429:8*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :429:29*/), ( /*line :429:32*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :429:54*/),
			( /*line :430:4*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :430:25*/),
			( /*line :431:4*/_Ciconst_DPI_ORACLE_TYPE_BFILE /*line :431:26*/),
			( /*line :432:4*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :432:24*/):
			isClob := typ == ( /*line :433:21*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :433:42*/) || typ == ( /*line :433:54*/_Ciconst_DPI_ORACLE_TYPE_NCLOB /*line :433:76*/)
			if isNull {
				if isClob && (r.ClobAsString() || !r.LobAsReader()) {
					dest[i] = ""
				} else {
					dest[i] = nil
				}
				continue
			}
			rdr := &dpiLobReader{dpiLob: ( /*line :442:33*/_Cfunc_dpiData_getLOB /*line :442:48*/)(d), conn: r.conn, IsClob: isClob}
			if isClob && (r.ClobAsString() || !r.LobAsReader()) {
				sb := stringBuilders.Get()
				_, err := io.Copy(sb, rdr)
				func() _Ctype_int{ _cgo0 := /*line :446:20*/rdr.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_close(_cgo0); }()
				if err != nil {
					stringBuilders.Put(sb)
					return err
				}
				dest[i] = sb.String()
				stringBuilders.Put(sb)
				continue
			}
			dest[i] = &Lob{Reader: rdr, IsClob: rdr.IsClob}

		case ( /*line :457:8*/_Ciconst_DPI_ORACLE_TYPE_STMT /*line :457:29*/), ( /*line :457:32*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :457:53*/):
			if isNull {
				dest[i] = nil
				continue
			}
			st := &statement{conn: r.conn, dpiStmt: ( /*line :462:44*/_Cfunc_dpiData_getStmt /*line :462:60*/)(d),
				stmtOptions: r.statement.stmtOptions, // inherit parent statement's options
			}
			var colCount  /*line :465:17*/_Ctype_uint32_t /*line :465:27*/
			if func() _Ctype_int{ _cgo0 := /*line :466:36*/st.dpiStmt; var _cgo1 *_Ctype_uint32_t = /*line :466:48*/&colCount; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getNumQueryColumns(_cgo0, _cgo1); }() == ( /*line :466:62*/_Ciconst_DPI_FAILURE /*line :466:74*/) {
				return errors.Errorf("getNumQueryColumns: %w", r.getError())
			}
			st.Lock()
			r2, err := st.openRows(int(colCount))
			st.Unlock()
			if err != nil {
				return err
			}
			dest[i] = r2

		case ( /*line :477:8*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :477:32*/), ( /*line :477:35*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :477:59*/):
			if isNull {
				dest[i] = nil
				continue
			}
			dest[i] = ( /*line :482:14*/_Cfunc_dpiData_getBool /*line :482:30*/)(d) == 1

		case ( /*line :484:8*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :484:31*/): //Default type used for named type columns in the database. Data is transferred to/from Oracle in Oracle's internal format.
			if isNull {
				dest[i] = nil
				continue
			}
			o, err := wrapObject(r.conn, col.ObjectType, ( /*line :489:49*/_Cfunc_dpiData_getObject /*line :489:67*/)(d))
			if err != nil {
				return err
			}
			dest[i] = o

		default:
			return errors.Errorf("unsupported column type %d", typ)
		}

		//fmt.Printf("dest[%d]=%#v\n", i, dest[i])
	}
	r.bufferRowIndex++
	r.fetched--

	if Log != nil {
		Log("msg", "scanned", "row", r.bufferRowIndex, "dest", dest)
	}

	return nil
}

var _ = driver.Rows((*directRow)(nil))

type directRow struct {
	args   []string
	result []interface{}
	query  string
	conn   *conn
}

func (dr *directRow) Columns() []string {
	if Log != nil {
		Log("directRow", "Columns")
	}
	switch dr.query {
	case getConnection:
		return []string{"CONNECTION"}
	}
	return nil
}

// Close closes the rows iterator.
func (dr *directRow) Close() error {
	dr.conn = nil
	dr.query = ""
	dr.args = nil
	dr.result = nil
	return nil
}

// Next is called to populate the next row of data into
// the provided slice. The provided slice will be the same
// size as the Columns() are wide.
//
// Next should return io.EOF when there are no more rows.
func (dr *directRow) Next(dest []driver.Value) error {
	if Log != nil {
		Log("directRow", "Next", "query", dr.query, "dest", dest)
	}
	switch dr.query {
	case getConnection:
		*(dest[0].(*interface{})) = dr.result[0]
	}
	return nil
}

func (r *rows) getImplicitResult() {
	if r == nil || r.nextRsErr != nil {
		return
	}
	// use the original statement for the NextResultSet call.
	st := r.origSt
	if st == nil {
		st = r.statement
		r.origSt = st
	}
	if func() _Ctype_int{ _cgo0 := /*line :566:33*/st.dpiStmt; _cgoBase1 := /*line :566:45*/&r.nextRs; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_dpiStmt_getImplicitResult(_cgo0, _cgo1); }() == ( /*line :566:59*/_Ciconst_DPI_FAILURE /*line :566:71*/) {
		r.nextRsErr = errors.Errorf("getImplicitResult: %w", r.getError())
	}
}
func (r *rows) HasNextResultSet() bool {
	if r == nil || r.statement == nil || r.conn == nil {
		return false
	}
	if r.nextRs != nil {
		return true
	}
	if !((r.conn.Client.Version > 12 || r.conn.Client.Version == 12 && r.conn.Client.Release >= 1) &&
		(r.conn.Server.Version > 12 || r.conn.Server.Version == 12 && r.conn.Server.Release >= 1)) {
		return false
	}
	r.getImplicitResult()
	return r.nextRs != nil
}
func (r *rows) NextResultSet() error {
	if r.nextRs == nil {
		r.getImplicitResult()
		if r.nextRsErr != nil {
			return r.nextRsErr
		}
		if r.nextRs == nil {
			return errors.Errorf("getImplicitResult: %w", io.EOF)
		}
	}
	st := &statement{conn: r.conn, dpiStmt: r.nextRs}

	var n  /*line :596:8*/_Ctype_uint32_t /*line :596:18*/
	if func() _Ctype_int{ _cgo0 := /*line :597:34*/st.dpiStmt; var _cgo1 *_Ctype_uint32_t = /*line :597:46*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getNumQueryColumns(_cgo0, _cgo1); }() == ( /*line :597:53*/_Ciconst_DPI_FAILURE /*line :597:65*/) {
		return errors.Errorf("getNumQueryColumns: %w: %w", r.getError(), io.EOF)
	}
	// keep the originam statement for the succeeding NextResultSet calls.
	nr, err := st.openRows(int(n))
	if err != nil {
		return err
	}
	nr.origSt = r.origSt
	if nr.origSt == nil {
		nr.origSt = r.statement
	}
	*r = *nr
	return nil
}

func printFloat(f float64) string {
	var a [40]byte
	b := strconv.AppendFloat(a[:0], f, 'f', -1, 64)
	i := bytes.IndexByte(b, '.')
	if i < 0 {
		return string(b)
	}
	for j := i + 1; j < len(b); j++ {
		if b[j] != '0' {
			return string(b)
		}
	}
	return string(b[:i])
}
