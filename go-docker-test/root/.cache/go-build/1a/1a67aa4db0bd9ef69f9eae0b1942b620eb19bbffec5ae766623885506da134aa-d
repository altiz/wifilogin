// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/obj.go:1:1
// Copyright 2017 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"unsafe"

	errors "golang.org/x/xerrors"
)

var _ = fmt.Printf

// Object represents a dpiObject.
type Object struct {
	ObjectType
	scratch   Data
	dpiObject * /*line :29:13*/_Ctype_dpiObject /*line :29:24*/
}

func (O *Object) getError() error { return O.conn.getError() }

// ErrNoSuchKey is the error for missing key in lookup.
var ErrNoSuchKey = errors.New("no such key")

// GetAttribute gets the i-th attribute into data.
func (O *Object) GetAttribute(data *Data, name string) error {
	if O == nil || O.dpiObject == nil {
		panic("nil dpiObject")
	}
	attr, ok := O.Attributes[name]
	if !ok {
		return errors.Errorf("%s: %w", name, ErrNoSuchKey)
	}

	data.reset()
	if data.dpiData == nil {
		data.dpiData = & /*line :49:19*/_Ctype_dpiData /*line :49:28*/{isNull: 0}
	}
	data.NativeTypeNum = attr.NativeTypeNum
	data.ObjectType = attr.ObjectType
	// the maximum length of that buffer must be supplied
	// in the value.asBytes.length attribute before calling this function.
	if attr.NativeTypeNum == ( /*line :55:27*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :55:49*/) && attr.OracleTypeNum == ( /*line :55:76*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :55:99*/) {
		var a [39]byte
		( /*line :57:3*/_Cfunc_dpiData_setBytes /*line :57:20*/)(data.dpiData, (* /*line :57:38*/_Ctype_char /*line :57:44*/)(unsafe.Pointer(&a[0])),  /*line :57:70*/_Ctype_uint32_t /*line :57:80*/(len(a)))
	}

	//fmt.Printf("getAttributeValue(%p, %p, %d, %+v)\n", O.dpiObject, attr.dpiObjectAttr, data.NativeTypeNum, data.dpiData)
	if func() _Ctype_int{ _cgo0 := /*line :61:35*/O.dpiObject; _cgo1 := /*line :61:48*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :61:68*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :61:88*/data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return _Cfunc_dpiObject_getAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :61:105*/_Ciconst_DPI_FAILURE /*line :61:117*/) {
		return errors.Errorf("getAttributeValue(%q, obj=%+v, attr=%+v, typ=%d): %w", name, O, attr.dpiObjectAttr, data.NativeTypeNum, O.getError())
	}
	//fmt.Printf("getAttributeValue(%p, %q=%p, %d, %+v)\n", O.dpiObject, attr.Name, attr.dpiObjectAttr, data.NativeTypeNum, data.dpiData)
	return nil
}

// SetAttribute sets the named attribute with data.
func (O *Object) SetAttribute(name string, data *Data) error {
	if !strings.Contains(name, `"`) {
		name = strings.ToUpper(name)
	}
	attr := O.Attributes[name]
	if data.NativeTypeNum == 0 {
		data.NativeTypeNum = attr.NativeTypeNum
		data.ObjectType = attr.ObjectType
	}
	if func() _Ctype_int{ _cgo0 := /*line :78:35*/O.dpiObject; _cgo1 := /*line :78:48*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :78:68*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :78:88*/data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return _Cfunc_dpiObject_setAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :78:105*/_Ciconst_DPI_FAILURE /*line :78:117*/) {
		return O.getError()
	}
	return nil
}

// Set is a convenience function to set the named attribute with the given value.
func (O *Object) Set(name string, v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.SetAttribute(name, data)
	}
	if err := O.scratch.Set(v); err != nil {
		return err
	}
	return O.SetAttribute(name, &O.scratch)
}

// ResetAttributes prepare all attributes for use the object as IN parameter
func (O *Object) ResetAttributes() error {
	var data Data
	for _, attr := range O.Attributes {
		data.reset()
		data.NativeTypeNum = attr.NativeTypeNum
		data.ObjectType = attr.ObjectType
		if attr.NativeTypeNum == ( /*line :102:28*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :102:50*/) && attr.OracleTypeNum == ( /*line :102:77*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :102:100*/) {
			a := make([]byte, attr.Precision)
			( /*line :104:4*/_Cfunc_dpiData_setBytes /*line :104:21*/)(data.dpiData, (* /*line :104:39*/_Ctype_char /*line :104:45*/)(unsafe.Pointer(&a[0])),  /*line :104:71*/_Ctype_uint32_t /*line :104:81*/(attr.Precision))
		}
		if func() _Ctype_int{ _cgo0 := /*line :106:36*/O.dpiObject; _cgo1 := /*line :106:49*/attr.dpiObjectAttr; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :106:69*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :106:89*/data.dpiData; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return _Cfunc_dpiObject_setAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :106:106*/_Ciconst_DPI_FAILURE /*line :106:118*/) {
			return O.getError()
		}
	}

	return nil
}

// Get scans the named attribute into dest, and returns it.
func (O *Object) Get(name string) (interface{}, error) {
	if err := O.GetAttribute(&O.scratch, name); err != nil {
		return nil, err
	}
	isObject := O.scratch.IsObject()
	if isObject {
		O.scratch.ObjectType = O.Attributes[name].ObjectType
	}
	v := O.scratch.Get()
	if !isObject {
		return v, nil
	}
	sub := v.(*Object)
	if sub != nil && sub.CollectionOf != nil {
		return &ObjectCollection{Object: sub}, nil
	}
	return sub, nil
}

// ObjectRef implements userType interface.
func (O *Object) ObjectRef() *Object {
	return O
}

// Collection returns &ObjectCollection{Object: O} iff the Object is a collection.
// Otherwise it returns nil.
func (O *Object) Collection() *ObjectCollection {
	if O.ObjectType.CollectionOf == nil {
		return nil
	}
	return &ObjectCollection{Object: O}
}

// Close releases a reference to the object.
func (O *Object) Close() error {
	obj := O.dpiObject
	O.dpiObject = nil
	if obj == nil {
		return nil
	}
	if func() _Ctype_int{ _cgo0 := /*line :155:25*/obj; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_release(_cgo0); }() == ( /*line :155:33*/_Ciconst_DPI_FAILURE /*line :155:45*/) {
		return errors.Errorf("error on close object: %w", O.getError())
	}

	return nil
}

// ObjectCollection represents a Collection of Objects - itself an Object, too.
type ObjectCollection struct {
	*Object
}

// ErrNotCollection is returned when the Object is not a collection.
var ErrNotCollection = errors.New("not collection")

// ErrNotExist is returned when the collection's requested element does not exist.
var ErrNotExist = errors.New("not exist")

// AsSlice retrieves the collection into a slice.
func (O *ObjectCollection) AsSlice(dest interface{}) (interface{}, error) {
	var dr reflect.Value
	needsInit := dest == nil
	if !needsInit {
		dr = reflect.ValueOf(dest)
	}
	for i, err := O.First(); err == nil; i, err = O.Next(i) {
		if O.CollectionOf.NativeTypeNum == ( /*line :181:38*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :181:61*/) {
			O.scratch.ObjectType = *O.CollectionOf
		}
		if err = O.GetItem(&O.scratch, i); err != nil {
			return dest, err
		}
		vr := reflect.ValueOf(O.scratch.Get())
		if needsInit {
			needsInit = false
			length, lengthErr := O.Len()
			if lengthErr != nil {
				return dr.Interface(), lengthErr
			}
			dr = reflect.MakeSlice(reflect.SliceOf(vr.Type()), 0, length)
		}
		dr = reflect.Append(dr, vr)
	}
	return dr.Interface(), nil
}

// AppendData to the collection.
func (O *ObjectCollection) AppendData(data *Data) error {
	if func() _Ctype_int{ _cgo0 := /*line :203:31*/O.dpiObject; var _cgo1 _Ctype_dpiNativeTypeNum = /*line :203:44*/data.NativeTypeNum; var _cgo2 *_Ctype_struct_dpiData = /*line :203:64*/data.dpiData; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_appendElement(_cgo0, _cgo1, _cgo2); }() == ( /*line :203:81*/_Ciconst_DPI_FAILURE /*line :203:93*/) {
		return errors.Errorf("append(%d): %w", data.NativeTypeNum, O.getError())
	}
	return nil
}

// Append v to the collection.
func (O *ObjectCollection) Append(v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.AppendData(data)
	}
	if err := O.scratch.Set(v); err != nil {
		return err
	}
	return O.AppendData(&O.scratch)
}

// AppendObject adds an Object to the collection.
func (O *ObjectCollection) AppendObject(obj *Object) error {
	O.scratch = Data{
		ObjectType:    obj.ObjectType,
		NativeTypeNum: ( /*line :224:18*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :224:41*/),
		dpiData:       & /*line :225:19*/_Ctype_dpiData /*line :225:28*/{isNull: 1},
	}
	O.scratch.SetObject(obj)
	return O.Append(&O.scratch)
}

// Delete i-th element of the collection.
func (O *ObjectCollection) Delete(i int) error {
	if func() _Ctype_int{ _cgo0 := /*line :233:38*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t(i); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_deleteElementByIndex(_cgo0, _cgo1); }() == ( /*line :233:68*/_Ciconst_DPI_FAILURE /*line :233:80*/) {
		return errors.Errorf("delete(%d): %w", i, O.getError())
	}
	return nil
}

// GetItem gets the i-th element of the collection into data.
func (O *ObjectCollection) GetItem(data *Data, i int) error {
	if data == nil {
		panic("data cannot be nil")
	}
	idx :=  /*line :244:9*/_Ctype_int32_t /*line :244:18*/(i)
	var exists  /*line :245:13*/_Ctype_int /*line :245:18*/
	if func() _Ctype_int{ _cgo0 := /*line :246:41*/O.dpiObject; var _cgo1 _Ctype_int32_t = /*line :246:54*/idx; var _cgo2 *_Ctype_int = /*line :246:59*/&exists; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getElementExistsByIndex(_cgo0, _cgo1, _cgo2); }() == ( /*line :246:71*/_Ciconst_DPI_FAILURE /*line :246:83*/) {
		return errors.Errorf("exists(%d): %w", idx, O.getError())
	}
	if exists == 0 {
		return ErrNotExist
	}
	data.reset()
	data.NativeTypeNum = O.CollectionOf.NativeTypeNum
	data.ObjectType = *O.CollectionOf
	if func() _Ctype_int{ _cgo0 := /*line :255:40*/O.dpiObject; var _cgo1 _Ctype_int32_t = /*line :255:53*/idx; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :255:58*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :255:78*/data.dpiData; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getElementValueByIndex(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :255:95*/_Ciconst_DPI_FAILURE /*line :255:107*/) {
		return errors.Errorf("get(%d[%d]): %w", idx, data.NativeTypeNum, O.getError())
	}
	return nil
}

// Get the i-th element of the collection.
func (O *ObjectCollection) Get(i int) (interface{}, error) {
	var data Data
	err := O.GetItem(&data, i)
	return data.Get(), err
}

// SetItem sets the i-th element of the collection with data.
func (O *ObjectCollection) SetItem(i int, data *Data) error {
	if func() _Ctype_int{ _cgo0 := /*line :270:40*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t(i); var _cgo2 _Ctype_dpiNativeTypeNum = /*line :270:67*/data.NativeTypeNum; var _cgo3 *_Ctype_struct_dpiData = /*line :270:87*/data.dpiData; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_setElementValueByIndex(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :270:104*/_Ciconst_DPI_FAILURE /*line :270:116*/) {
		return errors.Errorf("set(%d[%d]): %w", i, data.NativeTypeNum, O.getError())
	}
	return nil
}

// Set the i-th element of the collection with value.
func (O *ObjectCollection) Set(i int, v interface{}) error {
	if data, ok := v.(*Data); ok {
		return O.SetItem(i, data)
	}
	if err := O.scratch.Set(v); err != nil {
		return err
	}
	return O.SetItem(i, &O.scratch)
}

// First returns the first element's index of the collection.
func (O *ObjectCollection) First() (int, error) {
	var exists  /*line :289:13*/_Ctype_int /*line :289:18*/
	var idx  /*line :290:10*/_Ctype_int32_t /*line :290:19*/
	if func() _Ctype_int{ _cgo0 := /*line :291:31*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :291:44*/&idx; var _cgo2 *_Ctype_int = /*line :291:50*/&exists; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getFirstIndex(_cgo0, _cgo1, _cgo2); }() == ( /*line :291:62*/_Ciconst_DPI_FAILURE /*line :291:74*/) {
		return 0, errors.Errorf("first: %w", O.getError())
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Last returns the index of the last element.
func (O *ObjectCollection) Last() (int, error) {
	var exists  /*line :302:13*/_Ctype_int /*line :302:18*/
	var idx  /*line :303:10*/_Ctype_int32_t /*line :303:19*/
	if func() _Ctype_int{ _cgo0 := /*line :304:30*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :304:43*/&idx; var _cgo2 *_Ctype_int = /*line :304:49*/&exists; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getLastIndex(_cgo0, _cgo1, _cgo2); }() == ( /*line :304:61*/_Ciconst_DPI_FAILURE /*line :304:73*/) {
		return 0, errors.Errorf("last: %w", O.getError())
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Next returns the succeeding index of i.
func (O *ObjectCollection) Next(i int) (int, error) {
	var exists  /*line :315:13*/_Ctype_int /*line :315:18*/
	var idx  /*line :316:10*/_Ctype_int32_t /*line :316:19*/
	if func() _Ctype_int{ _cgo0 := /*line :317:30*/O.dpiObject; var _cgo1 _Ctype_int32_t = _Ctype_int32_t(i); var _cgo2 *_Ctype_int32_t = /*line :317:57*/&idx; var _cgo3 *_Ctype_int = /*line :317:63*/&exists; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getNextIndex(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :317:75*/_Ciconst_DPI_FAILURE /*line :317:87*/) {
		return 0, errors.Errorf("next(%d): %w", i, O.getError())
	}
	if exists == 1 {
		return int(idx), nil
	}
	return 0, ErrNotExist
}

// Len returns the length of the collection.
func (O *ObjectCollection) Len() (int, error) {
	var size  /*line :328:11*/_Ctype_int32_t /*line :328:20*/
	if func() _Ctype_int{ _cgo0 := /*line :329:25*/O.dpiObject; var _cgo1 *_Ctype_int32_t = /*line :329:38*/&size; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_getSize(_cgo0, _cgo1); }() == ( /*line :329:48*/_Ciconst_DPI_FAILURE /*line :329:60*/) {
		return 0, errors.Errorf("len: %w", O.getError())
	}
	return int(size), nil
}

// Trim the collection to n.
func (O *ObjectCollection) Trim(n int) error {
	if func() _Ctype_int{ _cgo0 := /*line :337:22*/O.dpiObject; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(n); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_trim(_cgo0, _cgo1); }() == ( /*line :337:53*/_Ciconst_DPI_FAILURE /*line :337:65*/) {
		return O.getError()
	}
	return nil
}

// ObjectType holds type info of an Object.
type ObjectType struct {
	dpiObjectType * /*line :345:17*/_Ctype_dpiObjectType /*line :345:32*/
	conn          *conn

	Schema, Name                        string
	DBSize, ClientSizeInBytes, CharSize int
	CollectionOf                        *ObjectType
	Attributes                          map[string]ObjectAttribute
	OracleTypeNum                        /*line :352:38*/_Ctype_dpiOracleTypeNum /*line :352:56*/
	NativeTypeNum                        /*line :353:38*/_Ctype_dpiNativeTypeNum /*line :353:56*/
	Precision                           int16
	Scale                               int8
	FsPrecision                         uint8
}

func (t ObjectType) getError() error { return t.conn.getError() }

func (t ObjectType) String() string {
	if t.Schema == "" {
		return t.Name
	}
	return t.Schema + "." + t.Name
}

// FullName returns the object's name with the schame prepended.
func (t ObjectType) FullName() string {
	if t.Schema == "" {
		return t.Name
	}
	return t.Schema + "." + t.Name
}

// GetObjectType returns the ObjectType of a name.
//
// The name is uppercased! Because here Oracle seems to be case-sensitive.
// To leave it as is, enclose it in "-s!
func (c *conn) GetObjectType(name string) (ObjectType, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	if !strings.Contains(name, "\"") {
		name = strings.ToUpper(name)
	}
	if o, ok := c.objTypes[name]; ok {
		return o, nil
	}
	cName := ( /*line :389:11*/_Cfunc_CString /*line :389:19*/)(name)
	defer func() { func() { _cgo0 := /*line :390:24*/unsafe.Pointer(cName); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }() }()
	objType := (* /*line :391:15*/_Ctype_dpiObjectType /*line :391:30*/)(( /*line :391:32*/_Cfunc__CMalloc /*line :391:39*/)(( /*line :391:41*/_Ciconst_sizeof_void /*line :391:53*/)))
	if func() _Ctype_int{ _cgo0 := /*line :392:29*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :392:40*/cName; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(name)); _cgoBase3 := /*line :392:70*/&objType; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return _Cfunc_dpiConn_getObjectType(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :392:83*/_Ciconst_DPI_FAILURE /*line :392:95*/) {
		func() { _cgo0 := /*line :393:10*/unsafe.Pointer(objType); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
		return ObjectType{}, errors.Errorf("getObjectType(%q) conn=%p: %w", name, c.dpiConn, c.getError())
	}
	t := ObjectType{conn: c, dpiObjectType: objType}
	err := t.init()
	if err == nil {
		c.objTypes[name] = t
	}
	return t, err
}

// NewObject returns a new Object with ObjectType type.
//
// As with all Objects, you MUST call Close on it when not needed anymore!
func (t ObjectType) NewObject() (*Object, error) {
	obj := (* /*line :408:11*/_Ctype_dpiObject /*line :408:22*/)(( /*line :408:24*/_Cfunc__CMalloc /*line :408:31*/)(( /*line :408:33*/_Ciconst_sizeof_void /*line :408:45*/)))
	if func() _Ctype_int{ _cgo0 := /*line :409:34*/t.dpiObjectType; _cgoBase1 := /*line :409:51*/&obj; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_dpiObjectType_createObject(_cgo0, _cgo1); }() == ( /*line :409:60*/_Ciconst_DPI_FAILURE /*line :409:72*/) {
		func() { _cgo0 := /*line :410:10*/unsafe.Pointer(obj); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
		return nil, t.getError()
	}
	O := &Object{ObjectType: t, dpiObject: obj}
	// https://github.com/oracle/odpi/issues/112#issuecomment-524479532
	return O, O.ResetAttributes()
}

// NewCollection returns a new Collection object with ObjectType type.
// If the ObjectType is not a Collection, it returns ErrNotCollection error.
func (t ObjectType) NewCollection() (*ObjectCollection, error) {
	if t.CollectionOf == nil {
		return nil, ErrNotCollection
	}
	O, err := t.NewObject()
	if err != nil {
		return nil, err
	}
	return &ObjectCollection{Object: O}, nil
}

// Close releases a reference to the object type.
func (t *ObjectType) close() error {
	if t == nil {
		return nil
	}
	attributes, d := t.Attributes, t.dpiObjectType
	t.Attributes, t.dpiObjectType = nil, nil

	for _, attr := range attributes {
		err := attr.Close()
		if err != nil {
			return err
		}
	}

	if d == nil {
		return nil
	}

	if func() _Ctype_int{ _cgo0 := /*line :450:29*/d; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObjectType_release(_cgo0); }() == ( /*line :450:35*/_Ciconst_DPI_FAILURE /*line :450:47*/) {
		return errors.Errorf("error on close object type: %w", t.getError())
	}

	return nil
}

func wrapObject(c *conn, objectType * /*line :457:38*/_Ctype_dpiObjectType /*line :457:53*/, object * /*line :457:63*/_Ctype_dpiObject /*line :457:74*/) (*Object, error) {
	if objectType == nil {
		return nil, errors.New("objectType is nil")
	}
	if func() _Ctype_int{ _cgo0 := /*line :461:24*/object; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_addRef(_cgo0); }() == ( /*line :461:35*/_Ciconst_DPI_FAILURE /*line :461:47*/) {
		return nil, c.getError()
	}
	o := &Object{
		ObjectType: ObjectType{dpiObjectType: objectType, conn: c},
		dpiObject:  object,
	}
	return o, o.init()
}

func (t *ObjectType) init() error {
	if t.conn == nil {
		panic("conn is nil")
	}
	if t.Name != "" && t.Attributes != nil {
		return nil
	}
	if t.dpiObjectType == nil {
		return nil
	}
	var info  /*line :481:11*/_Ctype_dpiObjectTypeInfo /*line :481:30*/
	if func() _Ctype_int{ _cgo0 := /*line :482:29*/t.dpiObjectType; _cgoBase1 := /*line :482:46*/&info; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_dpiObjectType_getInfo(_cgo0, _cgo1); }() == ( /*line :482:56*/_Ciconst_DPI_FAILURE /*line :482:68*/) {
		return errors.Errorf("%v.getInfo: %w", t, t.getError())
	}
	t.Schema = ( /*line :485:13*/_Cfunc_GoStringN /*line :485:23*/)(info.schema,  /*line :485:38*/_Ctype_int /*line :485:43*/(info.schemaLength))
	t.Name = ( /*line :486:11*/_Cfunc_GoStringN /*line :486:21*/)(info.name,  /*line :486:34*/_Ctype_int /*line :486:39*/(info.nameLength))
	t.CollectionOf = nil
	if t.conn.objTypes == nil {
		t.conn.objTypes = make(map[string]ObjectType)
	}

	numAttributes := int(info.numAttributes)
	if info.isCollection == 1 {
		t.CollectionOf = &ObjectType{conn: t.conn}
		if err := t.CollectionOf.fromDataTypeInfo(info.elementTypeInfo); err != nil {
			return err
		}
		if t.CollectionOf.Name == "" {
			t.CollectionOf.Schema = t.Schema
			t.CollectionOf.Name = t.Name
		}
	}
	if numAttributes == 0 {
		t.Attributes = map[string]ObjectAttribute{}
		t.conn.objTypes[t.FullName()] = *t
		return nil
	}
	t.Attributes = make(map[string]ObjectAttribute, numAttributes)
	attrs := make([]* /*line :509:19*/_Ctype_dpiObjectAttr /*line :509:34*/, numAttributes)
	if func() _Ctype_int{ _cgo0 := /*line :510:35*/t.dpiObjectType; var _cgo1 _Ctype_uint16_t = _Ctype_uint16_t(len(attrs)); _cgoIndex2 := &/*line :512:39*/attrs; _cgo2 := /*line :512:3*/(**_Ctype_dpiObjectAttr)(unsafe.Pointer(&(*_cgoIndex2)[0])); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return _Cfunc_dpiObjectType_getAttributes(_cgo0, _cgo1, _cgo2); }() == ( /*line :513:7*/_Ciconst_DPI_FAILURE /*line :513:19*/) {
		return errors.Errorf("%v.getAttributes: %w", t, t.getError())
	}
	for i, attr := range attrs {
		var attrInfo  /*line :517:16*/_Ctype_dpiObjectAttrInfo /*line :517:35*/
		if func() _Ctype_int{ _cgo0 := /*line :518:30*/attr; _cgoBase1 := /*line :518:36*/&attrInfo; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_dpiObjectAttr_getInfo(_cgo0, _cgo1); }() == ( /*line :518:50*/_Ciconst_DPI_FAILURE /*line :518:62*/) {
			return errors.Errorf("%v.attr_getInfo: %w", attr, t.getError())
		}
		if Log != nil {
			Log("i", i, "attrInfo", attrInfo)
		}
		typ := attrInfo.typeInfo
		sub, err := objectTypeFromDataTypeInfo(t.conn, typ)
		if err != nil {
			return err
		}
		objAttr := ObjectAttribute{
			dpiObjectAttr: attr,
			Name:          ( /*line :531:19*/_Cfunc_GoStringN /*line :531:29*/)(attrInfo.name,  /*line :531:46*/_Ctype_int /*line :531:51*/(attrInfo.nameLength)),
			ObjectType:    sub,
		}
		//fmt.Printf("%d=%q. typ=%+v sub=%+v\n", i, objAttr.Name, typ, sub)
		t.Attributes[objAttr.Name] = objAttr
	}
	t.conn.objTypes[t.FullName()] = *t
	return nil
}

func (t *ObjectType) fromDataTypeInfo(typ  /*line :541:43*/_Ctype_dpiDataTypeInfo /*line :541:60*/) error {
	t.dpiObjectType = typ.objectType

	t.OracleTypeNum = typ.oracleTypeNum
	t.NativeTypeNum = typ.defaultNativeTypeNum
	t.DBSize = int(typ.dbSizeInBytes)
	t.ClientSizeInBytes = int(typ.clientSizeInBytes)
	t.CharSize = int(typ.sizeInChars)
	t.Precision = int16(typ.precision)
	t.Scale = int8(typ.scale)
	t.FsPrecision = uint8(typ.fsPrecision)
	return t.init()
}
func objectTypeFromDataTypeInfo(conn *conn, typ  /*line :554:49*/_Ctype_dpiDataTypeInfo /*line :554:66*/) (ObjectType, error) {
	if conn == nil {
		panic("conn is nil")
	}
	if typ.oracleTypeNum == 0 {
		panic("typ is nil")
	}
	t := ObjectType{conn: conn}
	err := t.fromDataTypeInfo(typ)
	return t, err
}

// ObjectAttribute is an attribute of an Object.
type ObjectAttribute struct {
	Name          string
	dpiObjectAttr * /*line :569:17*/_Ctype_dpiObjectAttr /*line :569:32*/
	ObjectType
}

// Close the ObjectAttribute.
func (A ObjectAttribute) Close() error {
	attr := A.dpiObjectAttr
	A.dpiObjectAttr = nil

	if attr == nil {
		return nil
	}
	if func() _Ctype_int{ _cgo0 := /*line :581:29*/attr; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObjectAttr_release(_cgo0); }() == ( /*line :581:38*/_Ciconst_DPI_FAILURE /*line :581:50*/) {
		return A.getError()
	}
	return nil
}

// GetObjectType returns the ObjectType for the name.
func GetObjectType(ctx context.Context, ex Execer, typeName string) (ObjectType, error) {
	c, err := getConn(ctx, ex)
	if err != nil {
		return ObjectType{}, errors.Errorf("getConn for %s: %w", typeName, err)
	}
	return c.GetObjectType(typeName)
}
