// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/stmt.go:1:1
// Copyright 2017 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include <stdlib.h>
#include "dpiImpl.h"

const int sizeof_dpiData = sizeof(void);
*/
import _ "unsafe"
import (
	"context"
	"database/sql"
	"database/sql/driver"
	"fmt"
	"io"
	"reflect"
	"strconv"
	"sync"
	"time"
	"unsafe"

	errors "golang.org/x/xerrors"
)

type stmtOptions struct {
	fetchRowCount       int
	arraySize           int
	callTimeout         time.Duration
	execMode             /*line :34:22*/_Ctype_dpiExecMode /*line :34:35*/
	plSQLArrays         bool
	lobAsReader         bool
	magicTypeConversion bool
	numberAsString      bool
}

func (o stmtOptions) ExecMode()  /*line :41:33*/_Ctype_dpiExecMode /*line :41:46*/ {
	if o.execMode == 0 {
		return ( /*line :43:10*/_Ciconst_DPI_MODE_EXEC_DEFAULT /*line :43:32*/)
	}
	return o.execMode
}

func (o stmtOptions) ArraySize() int {
	if o.arraySize <= 0 {
		return DefaultArraySize
	} else if o.arraySize > 1<<16 {
		return 1 << 16
	}
	return o.arraySize
}
func (o stmtOptions) FetchRowCount() int {
	if o.fetchRowCount <= 0 {
		return DefaultFetchRowCount
	}
	return o.fetchRowCount
}
func (o stmtOptions) PlSQLArrays() bool { return o.plSQLArrays }

func (o stmtOptions) ClobAsString() bool { return !o.lobAsReader }
func (o stmtOptions) LobAsReader() bool  { return o.lobAsReader }

func (o stmtOptions) MagicTypeConversion() bool { return o.magicTypeConversion }
func (o stmtOptions) NumberAsString() bool      { return o.numberAsString }

// Option holds statement options.
type Option func(*stmtOptions)

// PlSQLArrays is to signal that the slices given in arguments of Exec to
// be left as is - the default is to treat them as arguments for ExecMany.
var PlSQLArrays Option = func(o *stmtOptions) { o.plSQLArrays = true }

// FetchRowCount returns an option to set the rows to be fetched, overriding DefaultFetchRowCount.
func FetchRowCount(rowCount int) Option {
	if rowCount <= 0 {
		return nil
	}
	return func(o *stmtOptions) { o.fetchRowCount = rowCount }
}

// ArraySize returns an option to set the array size to be used, overriding DefaultArraySize.
func ArraySize(arraySize int) Option {
	if arraySize <= 0 {
		return nil
	}
	return func(o *stmtOptions) { o.arraySize = arraySize }
}
func parseOnly(o *stmtOptions) { o.execMode = ( /*line :92:47*/_Ciconst_DPI_MODE_EXEC_PARSE_ONLY /*line :92:72*/) }

// ParseOnly returns an option to set the ExecMode to only Parse.
func ParseOnly() Option {
	return parseOnly
}

func describeOnly(o *stmtOptions) { o.execMode = ( /*line :99:50*/_Ciconst_DPI_MODE_EXEC_DESCRIBE_ONLY /*line :99:78*/) }

// ClobAsString returns an option to force fetching CLOB columns as strings.
//
// DEPRECATED.
func ClobAsString() Option { return func(o *stmtOptions) { o.lobAsReader = false } }

// LobAsReader is an option to set query columns of CLOB/BLOB to be returned as a Lob.
//
// LOB as a reader and writer is not the most performant at all. Yes, OCI
// and ODPI-C provide a way to retrieve this data directly. Effectively,
// all you need to do is tell ODPI-C that you want a "long string" or "long
// raw" returned. You can do that by telling ODPI-C you want a variable
// with oracleTypeNum=DPI_ORACLE_TYPE_LONG_VARCHAR or
// DPI_ORACLE_TYPE_LONG_RAW and nativeTypeNum=DPI_NATIVE_TYPE_BYTES. ODPI-C
// will handle all of the dynamic fetching and allocation that is required.
// :-) You can also use DPI_ORACLE_TYPE_VARCHAR and DPI_ORACLE_TYPE_RAW as
// long as you set the size > 32767 -- whichever way you wish to use.
//
// With the use of LOBs, there is one round-trip to get the LOB locators,
// then a round-trip for each read() that is performed. If you request the
// length there is another round-trip required. So if you fetch 100 rows
// with 2 CLOB columns, that means you get 401 round-trips. Using
// string/[]bytes directly means only one round trip. So you can see that
// if your database is remote with high latency you can have a significant
// performance penalty!
func LobAsReader() Option { return func(o *stmtOptions) { o.lobAsReader = true } }

// MagicTypeConversion returns an option to force converting named scalar types (e.g. "type underlying int64") to their scalar underlying type.
func MagicTypeConversion() Option {
	return func(o *stmtOptions) { o.magicTypeConversion = true }
}

// NumberAsString returns an option to return numbers as string, not Number.
func NumberAsString() Option {
	return func(o *stmtOptions) { o.numberAsString = true }
}

// CallTimeout sets the round-trip timeout (OCI_ATTR_CALL_TIMEOUT).
//
// See https://docs.oracle.com/en/database/oracle/oracle-database/18/lnoci/handle-and-descriptor-attributes.html#GUID-D8EE68EB-7E38-4068-B06E-DF5686379E5E
func CallTimeout(d time.Duration) Option {
	return func(o *stmtOptions) { o.callTimeout = d }
}

const minChunkSize = 1 << 16

var _ = driver.Stmt((*statement)(nil))
var _ = driver.StmtQueryContext((*statement)(nil))
var _ = driver.StmtExecContext((*statement)(nil))
var _ = driver.NamedValueChecker((*statement)(nil))

type statement struct {
	stmtOptions
	columns  []Column
	isSlice  []bool
	gets     []dataGetter
	dests    []interface{}
	data     [][] /*line :157:15*/_Ctype_dpiData /*line :157:24*/
	vars     []* /*line :158:14*/_Ctype_dpiVar /*line :158:22*/
	varInfos []varInfo
	query    string
	sync.Mutex
	arrLen int
	*conn
	dpiStmt     * /*line :164:15*/_Ctype_dpiStmt /*line :164:24*/
	isReturning bool
}
type dataGetter func(v interface{}, data [] /*line :167:44*/_Ctype_dpiData /*line :167:53*/) error

// Close closes the statement.
//
// As of Go 1.1, a Stmt will not be closed if it's in use
// by any queries.
func (st *statement) Close() error {
	if st == nil {
		return nil
	}
	st.Lock()
	defer st.Unlock()

	return st.close(false)
}
func (st *statement) close(keepDpiStmt bool) error {
	if st == nil {
		return nil
	}

	c, dpiStmt, vars := st.conn, st.dpiStmt, st.vars
	st.isSlice = nil
	st.query = ""
	st.data = nil
	st.vars = nil
	st.varInfos = nil
	st.gets = nil
	st.dests = nil
	st.columns = nil
	st.dpiStmt = nil
	st.conn = nil

	for _, v := range vars[:cap(vars)] {
		if v != nil {
			func() _Ctype_int{ _cgo0 := /*line :201:21*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_release(_cgo0); }()
		}
	}

	if !keepDpiStmt {
		var si  /*line :206:10*/_Ctype_dpiStmtInfo /*line :206:23*/
		if dpiStmt != nil &&
			func() _Ctype_int{ _cgo0 := /*line :208:22*/dpiStmt; var _cgo1 *_Ctype_struct_dpiStmtInfo = /*line :208:31*/&si; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getInfo(_cgo0, _cgo1); }() != ( /*line :208:39*/_Ciconst_DPI_FAILURE /*line :208:51*/) && // this is just to check the validity of dpiStmt, to avoid SIGSEGV
			func() _Ctype_int{ _cgo0 := /*line :209:22*/dpiStmt; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_release(_cgo0); }() != ( /*line :209:34*/_Ciconst_DPI_FAILURE /*line :209:46*/) {
			return nil
		}
	}
	if c == nil {
		return driver.ErrBadConn
	}
	if err := c.getError(); err != nil {
		return errors.Errorf("statement/dpiStmt_release: %w", err)
	}
	return nil
}

// Exec executes a query that doesn't return rows, such
// as an INSERT or UPDATE.
//
// Deprecated: Drivers should implement StmtExecContext instead (or additionally).
func (st *statement) Exec(args []driver.Value) (driver.Result, error) {
	nargs := make([]driver.NamedValue, len(args))
	for i, arg := range args {
		nargs[i].Ordinal = i + 1
		nargs[i].Value = arg
	}
	return st.ExecContext(context.Background(), nargs)
}

// Query executes a query that may return rows, such as a
// SELECT.
//
// Deprecated: Drivers should implement StmtQueryContext instead (or additionally).
func (st *statement) Query(args []driver.Value) (driver.Rows, error) {
	nargs := make([]driver.NamedValue, len(args))
	for i, arg := range args {
		nargs[i].Ordinal = i + 1
		nargs[i].Value = arg
	}
	return st.QueryContext(context.Background(), nargs)
}

// ExecContext executes a query that doesn't return rows, such as an INSERT or UPDATE.
//
// ExecContext must honor the context timeout and return when it is canceled.
//
// Cancelation/timeout is honored, execution is broken, but you may have to disable out-of-bound execution - see https://github.com/oracle/odpi/issues/116 for details.
func (st *statement) ExecContext(ctx context.Context, args []driver.NamedValue) (res driver.Result, err error) {
	if err = ctx.Err(); err != nil {
		return nil, err
	}
	Log := ctxGetLog(ctx)

	closeIfBadConn := func(err error) error {
		if err != nil && err == driver.ErrBadConn {
			if Log != nil {
				Log("error", err)
			}
			st.close(false)
			st.conn.close(true)
		}
		return err
	}

	st.Lock()
	defer st.Unlock()
	if st.dpiStmt == nil && st.query == getConnection {
		*(args[0].Value.(sql.Out).Dest.(*interface{})) = st.conn
		return driver.ResultNoRows, nil
	}
	st.isReturning = false

	st.conn.RLock()
	defer st.conn.RUnlock()

	// bind variables
	if err = st.bindVars(args, Log); err != nil {
		return nil, closeIfBadConn(err)
	}

	mode := st.ExecMode()
	//fmt.Printf("%p.%p: inTran? %t\n%s\n", st.conn, st, st.inTransaction, st.query)
	if !st.inTransaction {
		mode |= ( /*line :289:11*/_Ciconst_DPI_MODE_EXEC_COMMIT_ON_SUCCESS /*line :289:43*/)
	}
	st.setCallTimeout(ctx)

	done := make(chan error, 1)
	// execute
	go func() {
		defer close(done)
	Loop:
		for i := 0; i < 3; i++ {
			if err = ctx.Err(); err != nil {
				done <- err
				return
			}
			if !st.PlSQLArrays() && st.arrLen > 0 {
				if Log != nil {
					Log("C", "dpiStmt_executeMany", "mode", mode, "len", st.arrLen)
				}
				if func() _Ctype_int{ _cgo0 := /*line :307:30*/st.dpiStmt; var _cgo1 _Ctype_dpiExecMode = /*line :307:42*/mode; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(st.arrLen); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_executeMany(_cgo0, _cgo1, _cgo2); }() == ( /*line :307:74*/_Ciconst_DPI_FAILURE /*line :307:86*/) {
					if err = ctx.Err(); err == nil {
						err = st.getError()
					}
				}
			} else {
				var colCount  /*line :313:18*/_Ctype_uint32_t /*line :313:28*/
				if Log != nil {
					Log("C", "dpiStmt_execute", "mode", mode, "colCount", colCount)
				}
				if func() _Ctype_int{ _cgo0 := /*line :317:26*/st.dpiStmt; var _cgo1 _Ctype_dpiExecMode = /*line :317:38*/mode; var _cgo2 *_Ctype_uint32_t = /*line :317:44*/&colCount; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_execute(_cgo0, _cgo1, _cgo2); }() == ( /*line :317:58*/_Ciconst_DPI_FAILURE /*line :317:70*/) {
					if err = ctx.Err(); err == nil {
						err = st.getError()
					}
				}
			}
			if Log != nil {
				Log("msg", "st.Execute", "error", err)
			}
			if err == nil {
				var info  /*line :327:14*/_Ctype_dpiStmtInfo /*line :327:27*/
				if func() _Ctype_int{ _cgo0 := /*line :328:26*/st.dpiStmt; var _cgo1 *_Ctype_struct_dpiStmtInfo = /*line :328:38*/&info; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getInfo(_cgo0, _cgo1); }() == ( /*line :328:48*/_Ciconst_DPI_FAILURE /*line :328:60*/) {
					err = errors.Errorf("getInfo: %w", st.getError())
				}
				st.isReturning = info.isReturning != 0
				return
			}
			var cdr interface{ Code() int }
			if !errors.As(err, &cdr) {
				break
			}
			switch code := cdr.Code(); code {
			// ORA-04068: "existing state of packages has been discarded"
			case 4061, 4065, 4068:
				if Log != nil {
					Log("msg", "retry", "ora", code)
				}
				continue Loop
			}
			break
		}
		if err == nil {
			done <- nil
			return
		}
		done <- maybeBadConn(errors.Errorf("dpiStmt_execute(mode=%d arrLen=%d): %w", mode, st.arrLen, err), nil)
	}()

	select {
	case err = <-done:
		if err != nil {
			return nil, closeIfBadConn(err)
		}
	case <-ctx.Done():
		// select again to avoid race condition if both are done
		select {
		case err = <-done:
			if err != nil {
				return nil, closeIfBadConn(err)
			}
		case <-ctx.Done():
			if Log != nil {
				Log("msg", "BREAK statement")
			}
			_ = st.Break()
			st.close(false)
			if err := st.conn.Close(); err != nil {
				return nil, err
			}
			return nil, ctx.Err()
		}
	}

	if Log != nil {
		Log("gets", st.gets, "dests", st.dests)
	}
	for i, get := range st.gets {
		if get == nil {
			continue
		}
		if st.isReturning {
			var n  /*line :388:10*/_Ctype_uint32_t /*line :388:20*/
			data := &st.data[i][0]
			if func() _Ctype_int{ _cgo0 := /*line :390:32*/st.vars[i]; var _cgo1 _Ctype_uint32_t = /*line :390:44*/0; var _cgo2 *_Ctype_uint32_t = /*line :390:47*/&n; _cgoBase3 := /*line :390:51*/&data; _cgo3 := _cgoBase3; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase3, 0 == 0); return _Cfunc_dpiVar_getReturnedData(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :390:61*/_Ciconst_DPI_FAILURE /*line :390:73*/) {
				err = st.getError()
				return nil, errors.Errorf("%d.getReturnedData: %w", i, closeIfBadConn(err))
			}
			if n == 0 {
				st.data[i] = st.data[i][:0]
			} else {
				st.data[i] = (*(*[maxArraySize] /*line :397:36*/_Ctype_dpiData /*line :397:45*/)(unsafe.Pointer(data)))[:int(n):int(n)]
			}
		}
		dest := st.dests[i]
		if !st.isSlice[i] {
			if err = get(dest, st.data[i]); err != nil {
				if Log != nil {
					Log("get", i, "error", err)
				}
				return nil, errors.Errorf("%d. get[%d]: %w", i, 0, closeIfBadConn(err))
			}
			continue
		}
		var n  /*line :410:9*/_Ctype_uint32_t /*line :410:19*/ = 1
		if func() _Ctype_int{ _cgo0 := /*line :411:37*/st.vars[i]; var _cgo1 *_Ctype_uint32_t = /*line :411:49*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_getNumElementsInArray(_cgo0, _cgo1); }() == ( /*line :411:56*/_Ciconst_DPI_FAILURE /*line :411:68*/) {
			err = st.getError()
			if Log != nil {
				Log("msg", "getNumElementsInArray", "i", i, "error", err)
			}
			return nil, errors.Errorf("%d.getNumElementsInArray: %w", i, closeIfBadConn(err))
		}
		//fmt.Printf("i=%d dest=%T %#v\n", i, dest, dest)
		if err = get(dest, st.data[i][:n]); err != nil {
			if Log != nil {
				Log("msg", "get", "i", i, "n", n, "error", err)
			}
			return nil, errors.Errorf("%d. get: %w", i, closeIfBadConn(err))
		}
	}
	var count  /*line :426:12*/_Ctype_uint64_t /*line :426:22*/
	if func() _Ctype_int{ _cgo0 := /*line :427:27*/st.dpiStmt; var _cgo1 *_Ctype_uint64_t = /*line :427:39*/&count; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getRowCount(_cgo0, _cgo1); }() == ( /*line :427:50*/_Ciconst_DPI_FAILURE /*line :427:62*/) {
		return nil, nil
	}
	return driver.RowsAffected(count), nil
}

// QueryContext executes a query that may return rows, such as a SELECT.
//
// QueryContext must honor the context timeout and return when it is canceled.
//
// Cancelation/timeout is honored, execution is broken, but you may have to disable out-of-bound execution - see https://github.com/oracle/odpi/issues/116 for details.
func (st *statement) QueryContext(ctx context.Context, args []driver.NamedValue) (driver.Rows, error) {
	if err := ctx.Err(); err != nil {
		return nil, err
	}
	Log := ctxGetLog(ctx)

	closeIfBadConn := func(err error) error {
		if err != nil && err == driver.ErrBadConn {
			if Log != nil {
				Log("error", err)
			}
			st.close(false)
			st.conn.close(true)
		}
		return err
	}

	st.Lock()
	defer st.Unlock()
	st.isReturning = false
	st.conn.RLock()
	defer st.conn.RUnlock()

	switch st.query {
	case getConnection:
		if Log != nil {
			Log("msg", "QueryContext", "args", args)
		}
		return &directRow{conn: st.conn, query: st.query, result: []interface{}{st.conn}}, nil

	case wrapResultset:
		if Log != nil {
			Log("msg", "QueryContext", "args", args)
		}
		return args[0].Value.(driver.Rows), nil
	}

	//fmt.Printf("QueryContext(%+v)\n", args)
	// bind variables
	if err := st.bindVars(args, Log); err != nil {
		return nil, closeIfBadConn(err)
	}

	mode := st.ExecMode()
	//fmt.Printf("%p.%p: inTran? %t\n%s\n", st.conn, st, st.inTransaction, st.query)
	if !st.inTransaction {
		mode |= ( /*line :484:11*/_Ciconst_DPI_MODE_EXEC_COMMIT_ON_SUCCESS /*line :484:43*/)
	}

	// execute
	var colCount  /*line :488:15*/_Ctype_uint32_t /*line :488:25*/
	done := make(chan error, 1)
	go func() {
		var err error
		defer close(done)
		for i := 0; i < 3; i++ {
			if err = ctx.Err(); err != nil {
				done <- err
				return
			}
			st.setCallTimeout(ctx)
			if func() _Ctype_int{ _cgo0 := /*line :499:25*/st.dpiStmt; var _cgo1 _Ctype_dpiExecMode = /*line :499:37*/mode; var _cgo2 *_Ctype_uint32_t = /*line :499:43*/&colCount; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_execute(_cgo0, _cgo1, _cgo2); }() != ( /*line :499:57*/_Ciconst_DPI_FAILURE /*line :499:69*/) {
				break
			}
			if err = ctx.Err(); err == nil {
				err = st.getError()
				if c, ok := err.(interface{ Code() int }); ok && c.Code() != 4068 {
					break
				}
			}
		}
		if err == nil {
			done <- nil
			return
		}
		done <- maybeBadConn(errors.Errorf("dpiStmt_execute: %w", err), nil)
	}()

	select {
	case err := <-done:
		if err != nil {
			return nil, closeIfBadConn(err)
		}
	case <-ctx.Done():
		select {
		case err := <-done:
			if err != nil {
				return nil, closeIfBadConn(err)
			}
		case <-ctx.Done():
			if Log != nil {
				Log("msg", "BREAK query")
			}
			_ = st.Break()
			st.close(false)
			if err := st.conn.Close(); err != nil {
				return nil, err
			}
			return nil, ctx.Err()
		}
	}
	rows, err := st.openRows(int(colCount))
	return rows, closeIfBadConn(err)
}

// NumInput returns the number of placeholder parameters.
//
// If NumInput returns >= 0, the sql package will sanity check
// argument counts from callers and return errors to the caller
// before the statement's Exec or Query methods are called.
//
// NumInput may also return -1, if the driver doesn't know
// its number of placeholders. In that case, the sql package
// will not sanity check Exec or Query argument counts.
func (st *statement) NumInput() int {
	if st.query == wrapResultset {
		return 1
	}
	if st.dpiStmt == nil {
		switch st.query {
		case getConnection, wrapResultset:
			return 1
		}
		return 0
	}

	if !go10 {
		return -1
	}

	st.Lock()
	defer st.Unlock()
	var cnt  /*line :570:10*/_Ctype_uint32_t /*line :570:20*/
	//defer func() { fmt.Printf("%p.NumInput=%d (%q)\n", st, cnt, st.query) }()
	if func() _Ctype_int{ _cgo0 := /*line :572:28*/st.dpiStmt; var _cgo1 *_Ctype_uint32_t = /*line :572:40*/&cnt; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getBindCount(_cgo0, _cgo1); }() == ( /*line :572:49*/_Ciconst_DPI_FAILURE /*line :572:61*/) {
		return -1
	}
	if cnt < 2 { // 1 can't decrease...
		return int(cnt)
	}
	names := make([]* /*line :578:19*/_Ctype_char /*line :578:25*/, int(cnt))
	lengths := make([] /*line :579:20*/_Ctype_uint32_t /*line :579:30*/, int(cnt))
	if func() _Ctype_int{ _cgo0 := /*line :580:28*/st.dpiStmt; var _cgo1 *_Ctype_uint32_t = /*line :580:40*/&cnt; _cgoIndex2 := &/*line :580:47*/names; _cgo2 := /*line :580:46*/&(*_cgoIndex2)[0]; var _cgo3 *_Ctype_uint32_t = /*line :580:57*/&lengths[0]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, *_cgoIndex2); return _Cfunc_dpiStmt_getBindNames(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :580:73*/_Ciconst_DPI_FAILURE /*line :580:85*/) {
		return -1
	}
	//fmt.Printf("%p.NumInput=%d\n", st, cnt)

	// return the number of *unique* arguments
	return int(cnt)
}

func (st *statement) setCallTimeout(ctx context.Context) {
	if st.callTimeout != 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, st.callTimeout)
		_ = cancel
	}
	st.conn.setCallTimeout(ctx)
}

type argInfo struct {
	objType     * /*line :599:15*/_Ctype_dpiObjectType /*line :599:30*/
	set         dataSetter
	bufSize     int
	typ          /*line :602:14*/_Ctype_dpiOracleTypeNum /*line :602:32*/
	natTyp       /*line :603:14*/_Ctype_dpiNativeTypeNum /*line :603:32*/
	isIn, isOut bool
}

// bindVars binds the given args into new variables.
func (st *statement) bindVars(args []driver.NamedValue, Log logFunc) error {
	if Log != nil {
		Log("enter", "bindVars", "args", args)
	}
	for i, v := range st.vars[:cap(st.vars)] {
		if v != nil {
			func() _Ctype_int{ _cgo0 := /*line :614:21*/v; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_release(_cgo0); }()
			st.vars[i], st.varInfos[i] = nil, varInfo{}
		}
	}
	var named bool
	if cap(st.vars) < len(args) {
		st.vars = make([]* /*line :620:21*/_Ctype_dpiVar /*line :620:29*/, len(args))
	} else {
		st.vars = st.vars[:len(args)]
	}
	if cap(st.varInfos) < len(args) {
		st.varInfos = make([]varInfo, len(args))
	} else {
		st.varInfos = st.varInfos[:len(args)]
	}
	if cap(st.data) < len(args) {
		st.data = make([][] /*line :630:22*/_Ctype_dpiData /*line :630:31*/, len(args))
	} else {
		st.data = st.data[:len(args)]
	}
	if cap(st.gets) < len(args) {
		st.gets = make([]dataGetter, len(args))
	} else {
		st.gets = st.gets[:len(args)]
	}
	if cap(st.dests) < len(args) {
		st.dests = make([]interface{}, len(args))
	} else {
		st.dests = st.dests[:len(args)]
	}
	if cap(st.isSlice) < len(args) {
		st.isSlice = make([]bool, len(args))
	} else {
		st.isSlice = st.isSlice[:len(args)]
	}

	rArgs := make([]reflect.Value, len(args))
	minArrLen, maxArrLen := -1, -1

	st.arrLen = minArrLen
	maxArraySize := st.ArraySize()

	infos := make([]argInfo, len(args))
	//fmt.Printf("bindVars %d\n", len(args))
	for i, a := range args {
		st.gets[i] = nil
		st.dests[i] = nil
		if !named {
			named = a.Name != ""
		}
		info := &(infos[i])
		info.isIn = true
		value := a.Value
		if out, ok := value.(sql.Out); ok {
			if !st.PlSQLArrays() && st.arrLen > 1 {
				st.arrLen = maxArraySize
			}
			info.isIn, info.isOut = out.In, true
			value = out.Dest
		}
		st.dests[i] = value
		rv := reflect.ValueOf(value)
		if info.isOut {
			if rv.IsNil() {
				fmt.Printf("%d. v=%T %#v kind=%s\n", i, value, value, reflect.ValueOf(value).Kind())
			}
			if rv.Kind() == reflect.Ptr {
				rv = rv.Elem()
				value = rv.Interface()
			}
		}
		st.isSlice[i] = false
		rArgs[i] = rv
		if rv.Kind() == reflect.Ptr {
			// deref in rArgs, but NOT value!
			rArgs[i] = rv.Elem()
		}
		if _, isByteSlice := value.([]byte); !isByteSlice {
			st.isSlice[i] = rArgs[i].Kind() == reflect.Slice
			if !st.PlSQLArrays() && st.isSlice[i] {
				n := rArgs[i].Len()
				if minArrLen == -1 || n < minArrLen {
					minArrLen = n
				}
				if maxArrLen == -1 || n > maxArrLen {
					maxArrLen = n
				}
			}
		}

		if Log != nil {
			Log("msg", "bindVars", "i", i, "in", info.isIn, "out", info.isOut, "value", fmt.Sprintf("%T %#v", st.dests[i], st.dests[i]))
		}
	}

	if maxArrLen > maxArraySize {
		if st.arrLen == maxArraySize {
			st.arrLen = maxArrLen
		}
		maxArraySize = maxArrLen
	}
	doManyCount := 1
	doExecMany := !st.PlSQLArrays()
	if doExecMany {
		if minArrLen != -1 && minArrLen != maxArrLen {
			return errors.Errorf("PlSQLArrays is not set, but has different lengthed slices (min=%d < %d=max)", minArrLen, maxArrLen)
		}
		st.arrLen = minArrLen
		if doExecMany = st.arrLen > 1; doExecMany {
			doManyCount = st.arrLen
		}
	}
	if Log != nil {
		Log("doManyCount", doManyCount, "arrLen", st.arrLen, "doExecMany", doExecMany, "minArrLen", "maxArrLen")
	}

	for i := range args {
		info := &(infos[i])
		value := st.dests[i]

		var err error
		if value, err = st.bindVarTypeSwitch(info, &(st.gets[i]), value); err != nil {
			return errors.Errorf("%d. arg: %w", i+1, err)
		}

		var rv reflect.Value
		if st.isSlice[i] {
			rv = reflect.ValueOf(value)
		}

		n := doManyCount
		if st.PlSQLArrays() && st.isSlice[i] {
			n = rv.Len()
			if info.isOut {
				n = rv.Cap()
			}
		}
		if Log != nil {
			Log("msg", "newVar", "i", i, "plSQLArrays", st.PlSQLArrays(), "typ", int(info.typ), "natTyp", int(info.natTyp), "sliceLen", n, "bufSize", info.bufSize, "isSlice", st.isSlice[i])
		}
		//i, st.PlSQLArrays(), info.typ, info.natTyp dataSliceLen, info.bufSize)
		vi := varInfo{
			IsPLSArray: st.PlSQLArrays() && st.isSlice[i],
			Typ:        info.typ, NatTyp: info.natTyp,
			SliceLen: n, BufSize: info.bufSize,
			ObjectType: info.objType,
		}
		if vi.IsPLSArray && vi.SliceLen > maxArraySize {
			return errors.Errorf("maximum array size allowed is %d", maxArraySize)
		}
		if st.vars[i] == nil || st.data[i] == nil || st.varInfos[i] != vi {
			if st.vars[i], st.data[i], err = st.newVar(vi); err != nil {
				return errors.Errorf("%d: %w", i, err)
			}
			st.varInfos[i] = vi
		}

		// Have to setNumElementsInArray for the actual lengths for PL/SQL arrays
		dv, data := st.vars[i], st.data[i]
		if !info.isIn {
			if st.PlSQLArrays() {
				if Log != nil {
					Log("C", "dpiVar_setNumElementsInArray", "i", i, "n", 0)
				}
				if func() _Ctype_int{ _cgo0 := /*line :778:39*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(0); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_setNumElementsInArray(_cgo0, _cgo1); }() == ( /*line :778:61*/_Ciconst_DPI_FAILURE /*line :778:73*/) {
					return errors.Errorf("setNumElementsInArray[%d](%d): %w", i, 0, st.getError())
				}
			}
			continue
		}

		if !st.isSlice[i] {
			if Log != nil {
				Log("msg", "set", "i", i, "value", fmt.Sprintf("%T=%#v", value, value))
			}
			if err := info.set(dv, data[:1], value); err != nil {
				return errors.Errorf("set(data[%d][%d], %#v (%T)): %w", i, 0, value, value, err)
			}
			continue
		}

		if st.PlSQLArrays() {
			n = rv.Len()

			if Log != nil {
				Log("C", "dpiVar_setNumElementsInArray", "i", i, "n", n)
			}
			if func() _Ctype_int{ _cgo0 := /*line :801:38*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(n); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_setNumElementsInArray(_cgo0, _cgo1); }() == ( /*line :801:60*/_Ciconst_DPI_FAILURE /*line :801:72*/) {
				return errors.Errorf("%+v.setNumElementsInArray[%d](%d): %w", dv, i, n, st.getError())
			}
		}
		//fmt.Println("n:", len(st.data[i]))
		if err := info.set(dv, data, value); err != nil {
			return err
		}
	}

	if !named {
		for i, v := range st.vars {
			//if Log != nil {Log("C", "dpiStmt_bindByPos", "dpiStmt", st.dpiStmt, "i", i, "v", v) }
			if func() _Ctype_int{ _cgo0 := /*line :814:27*/st.dpiStmt; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i + 1); _cgo2 := /*line :814:56*/v; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_dpiStmt_bindByPos(_cgo0, _cgo1, _cgo2); }() == ( /*line :814:62*/_Ciconst_DPI_FAILURE /*line :814:74*/) {
				return errors.Errorf("bindByPos[%d]: %w", i, st.getError())
			}
		}
		return nil
	}
	for i, a := range args {
		name := a.Name
		if name == "" {
			name = strconv.Itoa(a.Ordinal)
		}
		//fmt.Printf("bindByName(%q)\n", name)
		cName := ( /*line :826:12*/_Cfunc_CString /*line :826:20*/)(name)
		res := func() _Ctype_int{ _cgo0 := /*line :827:31*/st.dpiStmt; var _cgo1 *_Ctype_char = /*line :827:43*/cName; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(name)); _cgo3 := /*line :827:73*/st.vars[i]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return _Cfunc_dpiStmt_bindByName(_cgo0, _cgo1, _cgo2, _cgo3); }()
		func() { _cgo0 := /*line :828:10*/unsafe.Pointer(cName); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
		if res == ( /*line :829:13*/_Ciconst_DPI_FAILURE /*line :829:25*/) {
			return errors.Errorf("bindByName[%q]: %w", name, st.getError())
		}
	}
	return nil
}

func (st *statement) bindVarTypeSwitch(info *argInfo, get *dataGetter, value interface{}) (interface{}, error) {
	nilPtr := false
	if Log != nil {
		Log("msg", "bindVarTypeSwitch", "info", info, "value", fmt.Sprintf("[%T]%v", value, value))
	}
	vlr, isValuer := value.(driver.Valuer)

	switch value.(type) {
	case *driver.Rows:
	default:
		var magic bool
		rv := reflect.ValueOf(value)
		kind := rv.Kind()
		if kind != reflect.Ptr {
			if magic = st.MagicTypeConversion(); magic {
				if isValuer {
					var err error
					if value, err = vlr.Value(); err != nil {
						return value, errors.Errorf("arg.Value(): %w", err)
					}
					return st.bindVarTypeSwitch(info, get, value)
				}
			}
		} else {
			if nilPtr = rv.IsNil(); nilPtr {
				info.set = dataSetNull
				value = reflect.Zero(rv.Type().Elem()).Interface()
			} else {
				value = rv.Elem().Interface()
			}
		}
		if magic {
			switch kind {
			case reflect.Bool,
				reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
				reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64,
				reflect.Float32, reflect.Float64,
				reflect.String:
			default:
				magic = false
			}
		}
		if magic {
			switch rv.Type().Name() {
			case "bool",
				"int", "int8", "int16", "int32", "int64",
				"uint", "uint8", "uint16", "uint32", "uint64",
				"float32", "float64",
				"string":
				// nothing to do
				magic = false
			default:
			}
		}
		if magic {
			switch kind {
			case reflect.Bool:
				value = rv.Bool()
			case reflect.Int:
				value = int(rv.Int())
			case reflect.Int8:
				value = int8(rv.Int())
			case reflect.Int16:
				value = int16(rv.Int())
			case reflect.Int32:
				value = int32(rv.Int())
			case reflect.Int64:
				value = rv.Int()
			case reflect.Uint:
				value = uint(rv.Uint())
			case reflect.Uint16:
				value = uint16(rv.Uint())
			case reflect.Uint32:
				value = uint32(rv.Uint())
			case reflect.Uint64:
				value = rv.Uint()
			case reflect.Float32:
				value = float32(rv.Float())
			case reflect.Float64:
				value = rv.Float()
			case reflect.String:
				value = rv.String()
			}
		}
	}

	switch v := value.(type) {
	case Lob, []Lob:
		info.typ, info.natTyp = ( /*line :924:27*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :924:48*/), ( /*line :924:51*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :924:71*/)
		var isClob bool
		switch v := v.(type) {
		case Lob:
			isClob = v.IsClob
		case []Lob:
			isClob = len(v) > 0 && v[0].IsClob
		}
		if isClob {
			info.typ = ( /*line :933:15*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :933:36*/)
		}
		info.set = st.dataSetLOB
		if info.isOut {
			*get = st.dataGetLOB
		}
	case *driver.Rows:
		info.typ, info.natTyp = ( /*line :940:27*/_Ciconst_DPI_ORACLE_TYPE_STMT /*line :940:48*/), ( /*line :940:51*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :940:72*/)
		info.set = dataSetNull
		if info.isOut {
			*get = st.dataGetStmt
		}
	case int, []int:
		info.typ, info.natTyp = ( /*line :946:27*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :946:50*/), ( /*line :946:53*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :946:75*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case int32, []int32:
		info.typ, info.natTyp = ( /*line :954:27*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :954:54*/), ( /*line :954:57*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :954:79*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case int64, []int64, sql.NullInt64, []sql.NullInt64:
		info.typ, info.natTyp = ( /*line :962:27*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :962:50*/), ( /*line :962:53*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :962:75*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case uint, []uint:
		info.typ, info.natTyp = ( /*line :970:27*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :970:50*/), ( /*line :970:53*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :970:76*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case uint32, []uint32:
		info.typ, info.natTyp = ( /*line :978:27*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :978:55*/), ( /*line :978:58*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :978:81*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case uint64, []uint64:
		info.typ, info.natTyp = ( /*line :986:27*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :986:50*/), ( /*line :986:53*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :986:76*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case float32, []float32:
		info.typ, info.natTyp = ( /*line :994:27*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :994:56*/), ( /*line :994:59*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :994:81*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case float64, []float64:
		info.typ, info.natTyp = ( /*line :1002:27*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :1002:57*/), ( /*line :1002:60*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :1002:83*/)
		if !nilPtr {
			info.set = dataSetNumber
			if info.isOut {
				*get = dataGetNumber
			}
		}
	case sql.NullFloat64, []sql.NullFloat64:
		info.typ, info.natTyp = ( /*line :1010:27*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :1010:57*/), ( /*line :1010:60*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :1010:83*/)
		info.set = dataSetNumber
		if info.isOut {
			*get = dataGetNumber
		}
	case bool, []bool:
		info.typ, info.natTyp = ( /*line :1016:27*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :1016:51*/), ( /*line :1016:54*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :1016:78*/)
		info.set = dataSetBool
		if info.isOut {
			*get = dataGetBool
		}

	case []byte, [][]byte:
		info.typ, info.natTyp = ( /*line :1023:27*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :1023:47*/), ( /*line :1023:50*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :1023:72*/)
		switch v := v.(type) {
		case []byte:
			info.bufSize = len(v)
		case [][]byte:
			for _, b := range v {
				if n := len(b); n > info.bufSize {
					info.bufSize = n
				}
			}
		}
		info.set = dataSetBytes
		if info.isOut {
			info.bufSize = 32767
			*get = dataGetBytes
		}

	case Number, []Number:
		info.typ, info.natTyp = ( /*line :1041:27*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :1041:50*/), ( /*line :1041:53*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :1041:75*/)
		switch v := v.(type) {
		case Number:
			info.bufSize = len(v)
		case []Number:
			for _, s := range v {
				if n := len(s); n > info.bufSize {
					info.bufSize = n
				}
			}
		}
		info.set = dataSetBytes
		if info.isOut {
			info.bufSize = 32767
			*get = dataGetBytes
		}

	case string, []string, nil:
		info.typ, info.natTyp = ( /*line :1059:27*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :1059:51*/), ( /*line :1059:54*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :1059:76*/)
		switch v := v.(type) {
		case string:
			info.bufSize = 4 * len(v)
		case []string:
			for _, s := range v {
				if n := 4 * len(s); n > info.bufSize {
					info.bufSize = n
				}
			}
		}
		info.set = dataSetBytes
		if info.isOut {
			info.bufSize = 32767
			*get = dataGetBytes
		}

	case time.Time, []time.Time:
		info.typ, info.natTyp = ( /*line :1077:27*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :1077:48*/), ( /*line :1077:51*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :1077:77*/)
		info.set = st.conn.dataSetTime
		if info.isOut {
			*get = st.conn.dataGetTime
		}

	case Object:
		info.objType = v.ObjectType.dpiObjectType
		info.typ, info.natTyp = ( /*line :1085:27*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :1085:50*/), ( /*line :1085:53*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :1085:76*/)
		info.set = st.dataSetObject
		if info.isOut {
			*get = st.dataGetObject
		}

	case *Object:
		if !nilPtr && v != nil {
			info.objType = v.ObjectType.dpiObjectType
			info.typ, info.natTyp = ( /*line :1094:28*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :1094:51*/), ( /*line :1094:54*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :1094:77*/)
		}
		info.set = st.dataSetObject
		if info.isOut {
			*get = st.dataGetObject
		}

	case userType:
		info.objType = v.ObjectRef().ObjectType.dpiObjectType
		info.typ, info.natTyp = ( /*line :1103:27*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :1103:50*/), ( /*line :1103:53*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :1103:76*/)
		info.set = st.dataSetObject
		if info.isOut {
			*get = st.dataGetObject
		}

	default:
		if !isValuer {
			return value, errors.Errorf("unknown type %T", value)
		}
		var err error
		if value, err = vlr.Value(); err != nil {
			return value, errors.Errorf("arg.Value(): %w", err)
		}
		return st.bindVarTypeSwitch(info, get, value)
	}

	return value, nil
}

type dataSetter func(dv * /*line :1123:26*/_Ctype_dpiVar /*line :1123:34*/, data [] /*line :1123:43*/_Ctype_dpiData /*line :1123:52*/, vv interface{}) error

func dataSetNull(dv * /*line :1125:22*/_Ctype_dpiVar /*line :1125:30*/, data [] /*line :1125:39*/_Ctype_dpiData /*line :1125:48*/, vv interface{}) error {
	for i := range data {
		data[i].isNull = 1
	}
	return nil
}
func dataGetBool(v interface{}, data [] /*line :1131:40*/_Ctype_dpiData /*line :1131:49*/) error {
	if b, ok := v.(*bool); ok {
		if len(data) == 0 || data[0].isNull == 1 {
			*b = false
			return nil
		}
		*b = ( /*line :1137:8*/_Cfunc_dpiData_getBool /*line :1137:24*/)(&data[0]) == 1
		return nil
	}
	slice := v.(*[]bool)
	if cap(*slice) >= len(data) {
		*slice = (*slice)[:len(data)]
	} else {
		*slice = make([]bool, len(data))
	}
	for i := range data {
		if data[i].isNull == 1 {
			(*slice)[i] = false
			continue
		}
		(*slice)[i] = ( /*line :1151:17*/_Cfunc_dpiData_getBool /*line :1151:33*/)(&data[i]) == 1
	}
	return nil
}
func dataSetBool(dv * /*line :1155:22*/_Ctype_dpiVar /*line :1155:30*/, data [] /*line :1155:39*/_Ctype_dpiData /*line :1155:48*/, vv interface{}) error {
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}
	b :=  /*line :1159:7*/_Ctype_int /*line :1159:12*/(0)
	if v, ok := vv.(bool); ok {
		if v {
			b = 1
		}
		( /*line :1164:3*/_Cfunc_dpiData_setBool /*line :1164:19*/)(&data[0], b)
		return nil
	}
	if bb, ok := vv.([]bool); ok {
		for i, v := range bb {
			if v {
				b = 1
			}
			( /*line :1172:4*/_Cfunc_dpiData_setBool /*line :1172:20*/)(&data[i], b)
		}
		return nil
	}
	for i := range data {
		data[i].isNull = 1
	}
	return nil
}
func (c *conn) dataGetTime(v interface{}, data [] /*line :1181:50*/_Ctype_dpiData /*line :1181:59*/) error {
	if x, ok := v.(*time.Time); ok {
		if len(data) == 0 || data[0].isNull == 1 {
			*x = time.Time{}
			return nil
		}
		c.dataGetTimeC(x, &data[0])
		return nil
	}
	slice := v.(*[]time.Time)
	n := len(data)
	if cap(*slice) >= n {
		*slice = (*slice)[:n]
	} else {
		*slice = make([]time.Time, n)
	}
	for i := range data {
		c.dataGetTimeC(&((*slice)[i]), &data[i])
	}
	return nil
}

func (c *conn) dataGetTimeC(t *time.Time, data * /*line :1203:49*/_Ctype_dpiData /*line :1203:58*/) {
	if data.isNull == 1 {
		*t = time.Time{}
		return
	}
	ts := ( /*line :1208:8*/_Cfunc_dpiData_getTimestamp /*line :1208:29*/)(data)
	tz := c.timeZone
	if ts.tzHourOffset != 0 || ts.tzMinuteOffset != 0 {
		tz = timeZoneFor(ts.tzHourOffset, ts.tzMinuteOffset)
	}
	*t = time.Date(
		int(ts.year), time.Month(ts.month), int(ts.day),
		int(ts.hour), int(ts.minute), int(ts.second), int(ts.fsecond),
		tz,
	)
}

func (c *conn) dataSetTime(dv * /*line :1220:32*/_Ctype_dpiVar /*line :1220:40*/, data [] /*line :1220:49*/_Ctype_dpiData /*line :1220:58*/, vv interface{}) error {
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}
	times := []time.Time{{}}
	if t, ok := vv.(time.Time); ok {
		times[0] = t
	} else {
		var ok bool
		if times, ok = vv.([]time.Time); !ok {
			for i := range data {
				data[i].isNull = 1
			}
			return nil
		}
	}
	tzHour, tzMin :=  /*line :1236:19*/_Ctype_int8_t /*line :1236:27*/(c.tzOffSecs/3600),  /*line :1236:47*/_Ctype_int8_t /*line :1236:55*/((c.tzOffSecs%3600)/60)
	for i, t := range times {
		if t.IsZero() {
			data[i].isNull = 1
			continue
		}
		data[i].isNull = 0
		t = t.In(c.timeZone)
		Y, M, D := t.Date()
		h, m, s := t.Clock()
		( /*line :1246:3*/_Cfunc_dpiData_setTimestamp /*line :1246:24*/)(&data[i],
			 /*line :1247:4*/_Ctype_int16_t /*line :1247:13*/(Y),  /*line :1247:18*/_Ctype_uint8_t /*line :1247:27*/(M),  /*line :1247:32*/_Ctype_uint8_t /*line :1247:41*/(D),
			 /*line :1248:4*/_Ctype_uint8_t /*line :1248:13*/(h),  /*line :1248:18*/_Ctype_uint8_t /*line :1248:27*/(m),  /*line :1248:32*/_Ctype_uint8_t /*line :1248:41*/(s),  /*line :1248:46*/_Ctype_uint32_t /*line :1248:56*/(t.Nanosecond()),
			tzHour, tzMin,
		)
	}
	return nil
}

func dataGetNumber(v interface{}, data [] /*line :1255:42*/_Ctype_dpiData /*line :1255:51*/) error {
	switch x := v.(type) {
	case *int:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = int(( /*line :1261:13*/_Cfunc_dpiData_getInt64 /*line :1261:30*/)(&data[0]))
		}
	case *[]int:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, int(( /*line :1269:25*/_Cfunc_dpiData_getInt64 /*line :1269:42*/)(&data[i])))
			}
		}
	case *int32:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = int32(( /*line :1276:15*/_Cfunc_dpiData_getInt64 /*line :1276:32*/)(&data[0]))
		}
	case *[]int32:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, int32(( /*line :1284:27*/_Cfunc_dpiData_getInt64 /*line :1284:44*/)(&data[i])))
			}
		}
	case *int64:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = int64(( /*line :1291:15*/_Cfunc_dpiData_getInt64 /*line :1291:32*/)(&data[0]))
		}
	case *[]int64:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, int64(( /*line :1299:27*/_Cfunc_dpiData_getInt64 /*line :1299:44*/)(&data[i])))
			}
		}
	case *sql.NullInt64:
		if len(data) == 0 || data[0].isNull == 1 {
			x.Valid = false
		} else {
			x.Valid, x.Int64 = true, int64(( /*line :1306:35*/_Cfunc_dpiData_getInt64 /*line :1306:52*/)(&data[0]))
		}
	case *[]sql.NullInt64:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, sql.NullInt64{Valid: false})
			} else {
				*x = append(*x, sql.NullInt64{Valid: true,
					Int64: int64(( /*line :1315:19*/_Cfunc_dpiData_getInt64 /*line :1315:36*/)(&data[i]))})
			}
		}
	case *sql.NullFloat64:
		if len(data) == 0 || data[0].isNull == 1 {
			x.Valid = false
		} else {
			x.Valid, x.Float64 = true, float64(( /*line :1322:39*/_Cfunc_dpiData_getDouble /*line :1322:57*/)(&data[0]))
		}
	case *[]sql.NullFloat64:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, sql.NullFloat64{Valid: false})
			} else {
				*x = append(*x, sql.NullFloat64{Valid: true, Float64: float64(( /*line :1330:67*/_Cfunc_dpiData_getDouble /*line :1330:85*/)(&data[i]))})
			}
		}

	case *uint:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = uint(( /*line :1338:14*/_Cfunc_dpiData_getUint64 /*line :1338:32*/)(&data[0]))
		}
	case *[]uint:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, uint(( /*line :1346:26*/_Cfunc_dpiData_getUint64 /*line :1346:44*/)(&data[i])))
			}
		}
	case *uint32:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = uint32(( /*line :1353:16*/_Cfunc_dpiData_getUint64 /*line :1353:34*/)(&data[0]))
		}
	case *[]uint32:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, uint32(( /*line :1361:28*/_Cfunc_dpiData_getUint64 /*line :1361:46*/)(&data[i])))
			}
		}
	case *uint64:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = uint64(( /*line :1368:16*/_Cfunc_dpiData_getUint64 /*line :1368:34*/)(&data[0]))
		}
	case *[]uint64:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, uint64(( /*line :1376:28*/_Cfunc_dpiData_getUint64 /*line :1376:46*/)(&data[i])))
			}
		}

	case *float32:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = float32(( /*line :1384:17*/_Cfunc_dpiData_getFloat /*line :1384:34*/)(&data[0]))
		}
	case *[]float32:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, float32(( /*line :1392:29*/_Cfunc_dpiData_getFloat /*line :1392:46*/)(&data[i])))
			}
		}
	case *float64:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = 0
		} else {
			*x = float64(( /*line :1399:17*/_Cfunc_dpiData_getDouble /*line :1399:35*/)(&data[0]))
		}
	case *[]float64:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, 0)
			} else {
				*x = append(*x, float64(( /*line :1407:29*/_Cfunc_dpiData_getDouble /*line :1407:47*/)(&data[i])))
			}
		}

	default:
		return errors.Errorf("unknown number [%T] %#v", v, v)
	}

	//fmt.Printf("setInt64(%#v, %#v)\n", data, C.int64_t(int64(v.(int))))
	return nil
}

func dataSetNumber(dv * /*line :1419:24*/_Ctype_dpiVar /*line :1419:32*/, data [] /*line :1419:41*/_Ctype_dpiData /*line :1419:50*/, vv interface{}) error {
	if len(data) == 0 {
		return nil
	}
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}
	switch slice := vv.(type) {
	case int:
		i, x := 0, slice
		( /*line :1429:3*/_Cfunc_dpiData_setInt64 /*line :1429:20*/)(&data[i],  /*line :1429:32*/_Ctype_int64_t /*line :1429:41*/(x))
	case []int:
		for i, x := range slice {
			( /*line :1432:4*/_Cfunc_dpiData_setInt64 /*line :1432:21*/)(&data[i],  /*line :1432:33*/_Ctype_int64_t /*line :1432:42*/(x))
		}
	case int32:
		i, x := 0, slice
		( /*line :1436:3*/_Cfunc_dpiData_setInt64 /*line :1436:20*/)(&data[i],  /*line :1436:32*/_Ctype_int64_t /*line :1436:41*/(x))
	case []int32:
		for i, x := range slice {
			( /*line :1439:4*/_Cfunc_dpiData_setInt64 /*line :1439:21*/)(&data[i],  /*line :1439:33*/_Ctype_int64_t /*line :1439:42*/(x))
		}
	case int64:
		i, x := 0, slice
		( /*line :1443:3*/_Cfunc_dpiData_setInt64 /*line :1443:20*/)(&data[i],  /*line :1443:32*/_Ctype_int64_t /*line :1443:41*/(x))
	case []int64:
		for i, x := range slice {
			( /*line :1446:4*/_Cfunc_dpiData_setInt64 /*line :1446:21*/)(&data[i],  /*line :1446:33*/_Ctype_int64_t /*line :1446:42*/(x))
		}
	case sql.NullInt64:
		i, x := 0, slice
		if x.Valid {
			data[i].isNull = 0
			( /*line :1452:4*/_Cfunc_dpiData_setInt64 /*line :1452:21*/)(&data[i],  /*line :1452:33*/_Ctype_int64_t /*line :1452:42*/(x.Int64))
		} else {
			data[i].isNull = 1
		}
	case []sql.NullInt64:
		for i, x := range slice {
			if x.Valid {
				data[i].isNull = 0
				( /*line :1460:5*/_Cfunc_dpiData_setInt64 /*line :1460:22*/)(&data[i],  /*line :1460:34*/_Ctype_int64_t /*line :1460:43*/(x.Int64))
			} else {
				data[i].isNull = 1
			}
		}
	case sql.NullFloat64:
		i, x := 0, slice
		if x.Valid {
			data[i].isNull = 0
			( /*line :1469:4*/_Cfunc_dpiData_setDouble /*line :1469:22*/)(&data[i],  /*line :1469:34*/_Ctype_double /*line :1469:42*/(x.Float64))
		} else {
			data[i].isNull = 1
		}
	case []sql.NullFloat64:
		for i, x := range slice {
			if x.Valid {
				data[i].isNull = 0
				( /*line :1477:5*/_Cfunc_dpiData_setDouble /*line :1477:23*/)(&data[i],  /*line :1477:35*/_Ctype_double /*line :1477:43*/(x.Float64))
			} else {
				data[i].isNull = 1
			}
		}

	case uint:
		i, x := 0, slice
		( /*line :1485:3*/_Cfunc_dpiData_setUint64 /*line :1485:21*/)(&data[i],  /*line :1485:33*/_Ctype_uint64_t /*line :1485:43*/(x))
	case []uint:
		for i, x := range slice {
			( /*line :1488:4*/_Cfunc_dpiData_setUint64 /*line :1488:22*/)(&data[i],  /*line :1488:34*/_Ctype_uint64_t /*line :1488:44*/(x))
		}
	case uint32:
		i, x := 0, slice
		( /*line :1492:3*/_Cfunc_dpiData_setUint64 /*line :1492:21*/)(&data[i],  /*line :1492:33*/_Ctype_uint64_t /*line :1492:43*/(x))
	case []uint32:
		for i, x := range slice {
			( /*line :1495:4*/_Cfunc_dpiData_setUint64 /*line :1495:22*/)(&data[i],  /*line :1495:34*/_Ctype_uint64_t /*line :1495:44*/(x))
		}
	case uint64:
		i, x := 0, slice
		( /*line :1499:3*/_Cfunc_dpiData_setUint64 /*line :1499:21*/)(&data[i],  /*line :1499:33*/_Ctype_uint64_t /*line :1499:43*/(x))
	case []uint64:
		for i, x := range slice {
			( /*line :1502:4*/_Cfunc_dpiData_setUint64 /*line :1502:22*/)(&data[i],  /*line :1502:34*/_Ctype_uint64_t /*line :1502:44*/(x))
		}

	case float32:
		i, x := 0, slice
		( /*line :1507:3*/_Cfunc_dpiData_setFloat /*line :1507:20*/)(&data[i],  /*line :1507:32*/_Ctype_float /*line :1507:39*/(x))
	case []float32:
		for i, x := range slice {
			( /*line :1510:4*/_Cfunc_dpiData_setFloat /*line :1510:21*/)(&data[i],  /*line :1510:33*/_Ctype_float /*line :1510:40*/(x))
		}
	case float64:
		i, x := 0, slice
		( /*line :1514:3*/_Cfunc_dpiData_setDouble /*line :1514:21*/)(&data[i],  /*line :1514:33*/_Ctype_double /*line :1514:41*/(x))
	case []float64:
		for i, x := range slice {
			( /*line :1517:4*/_Cfunc_dpiData_setDouble /*line :1517:22*/)(&data[i],  /*line :1517:34*/_Ctype_double /*line :1517:42*/(x))
		}

	default:
		return errors.Errorf("unknown number slice [%T] %#v", vv, vv)
	}

	//fmt.Printf("setInt64(%#v, %#v)\n", data, C.int64_t(int64(v.(int))))
	return nil
}

func dataGetBytes(v interface{}, data [] /*line :1528:41*/_Ctype_dpiData /*line :1528:50*/) error {
	switch x := v.(type) {
	case *[]byte:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = nil
			return nil
		}
		db := ( /*line :1535:9*/_Cfunc_dpiData_getBytes /*line :1535:26*/)(&data[0])
		b := ((*[32767]byte)(unsafe.Pointer(db.ptr)))[:db.length:db.length]
		// b must be copied
		*x = append((*x)[:0], b...)

	case *[][]byte:
		maX := (*x)[:cap(*x)]
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, nil)
				continue
			}
			db := ( /*line :1548:10*/_Cfunc_dpiData_getBytes /*line :1548:27*/)(&data[i])
			b := ((*[32767]byte)(unsafe.Pointer(db.ptr)))[:db.length:db.length]
			// b must be copied
			if i < len(maX) {
				*x = append(*x, append(maX[i][:0], b...))
			} else {
				*x = append(*x, append(make([]byte, 0, len(b)), b...))
			}
		}

	case *Number:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = ""
			return nil
		}
		b := ( /*line :1563:8*/_Cfunc_dpiData_getBytes /*line :1563:25*/)(&data[0])
		*x = Number(((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length])
	case *[]Number:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, "")
				continue
			}
			b := ( /*line :1572:9*/_Cfunc_dpiData_getBytes /*line :1572:26*/)(&data[i])
			*x = append(*x, Number(((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length]))
		}

	case *string:
		if len(data) == 0 || data[0].isNull == 1 {
			*x = ""
			return nil
		}
		b := ( /*line :1581:8*/_Cfunc_dpiData_getBytes /*line :1581:25*/)(&data[0])
		*x = string(((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length])
	case *[]string:
		*x = (*x)[:0]
		for i := range data {
			if data[i].isNull == 1 {
				*x = append(*x, "")
				continue
			}
			b := ( /*line :1590:9*/_Cfunc_dpiData_getBytes /*line :1590:26*/)(&data[i])
			*x = append(*x, string(((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length]))
		}

	case *interface{}:
		switch y := (*x).(type) {
		case []byte:
			err := dataGetBytes(&y, data[:1])
			*x = y
			return err
		case [][]byte:
			err := dataGetBytes(&y, data)
			*x = y
			return err

		case Number:
			err := dataGetBytes(&y, data[:1])
			*x = y
			return err
		case []Number:
			err := dataGetBytes(&y, data)
			*x = y
			return err

		case string:
			err := dataGetBytes(&y, data[:1])
			*x = y
			return err
		case []string:
			err := dataGetBytes(&y, data)
			*x = y
			return err

		default:
			return errors.Errorf("awaited []byte/string/Number, got %T (%#v)", x, x)
		}

	default:
		return errors.Errorf("awaited []byte/string/Number, got %T (%#v)", v, v)
	}
	return nil
}

func dataSetBytes(dv * /*line :1633:23*/_Ctype_dpiVar /*line :1633:31*/, data [] /*line :1633:40*/_Ctype_dpiData /*line :1633:49*/, vv interface{}) error {
	if len(data) == 0 {
		return nil
	}
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}
	var p * /*line :1640:9*/_Ctype_char /*line :1640:15*/
	switch slice := vv.(type) {
	case []byte:
		i, x := 0, slice
		if len(x) == 0 {
			data[i].isNull = 1
			return nil
		}
		data[i].isNull = 0
		p = (* /*line :1649:9*/_Ctype_char /*line :1649:15*/)(unsafe.Pointer(&x[0]))
		//if Log != nil {Log("C", "dpiVar_setFromBytes", "dv", dv, "pos", pos, "p", p, "len", len(x)) }
		func() _Ctype_int{ _cgo0 := /*line :1651:25*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i); var _cgo2 *_Ctype_char = /*line :1651:44*/p; var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t(len(x)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_setFromBytes(_cgo0, _cgo1, _cgo2, _cgo3); }()
	case [][]byte:
		for i, x := range slice {
			if len(x) == 0 {
				data[i].isNull = 1
				continue
			}
			data[i].isNull = 0
			p = (* /*line :1659:10*/_Ctype_char /*line :1659:16*/)(unsafe.Pointer(&x[0]))
			//if Log != nil {Log("C", "dpiVar_setFromBytes", "dv", dv, "pos", pos, "p", p, "len", len(x)) }
			func() _Ctype_int{ _cgo0 := /*line :1661:26*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i); var _cgo2 *_Ctype_char = /*line :1661:45*/p; var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t(len(x)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiVar_setFromBytes(_cgo0, _cgo1, _cgo2, _cgo3); }()
		}

	case Number:
		i, x := 0, slice
		if len(x) == 0 {
			data[i].isNull = 1
			return nil
		}
		data[i].isNull = 0
		dpiSetFromString(dv,  /*line :1671:24*/_Ctype_uint32_t /*line :1671:34*/(i), string(x))
	case []Number:
		for i, x := range slice {
			if len(x) == 0 {
				data[i].isNull = 1
				continue
			}
			data[i].isNull = 0
			dpiSetFromString(dv,  /*line :1679:25*/_Ctype_uint32_t /*line :1679:35*/(i), string(x))
		}

	case string:
		i, x := 0, slice
		if len(x) == 0 {
			data[i].isNull = 1
			return nil
		}
		data[i].isNull = 0
		dpiSetFromString(dv,  /*line :1689:24*/_Ctype_uint32_t /*line :1689:34*/(i), x)
	case []string:
		for i, x := range slice {
			if len(x) == 0 {
				data[i].isNull = 1
				continue
			}
			data[i].isNull = 0
			dpiSetFromString(dv,  /*line :1697:25*/_Ctype_uint32_t /*line :1697:35*/(i), x)
		}

	default:
		return errors.Errorf("awaited [][]byte/[]string/[]Number, got %T (%#v)", vv, vv)
	}
	return nil
}

func (c *conn) dataGetStmt(v interface{}, data [] /*line :1706:50*/_Ctype_dpiData /*line :1706:59*/) error {
	if row, ok := v.(*driver.Rows); ok {
		if len(data) == 0 || data[0].isNull == 1 {
			*row = nil
			return nil
		}
		return c.dataGetStmtC(row, &data[0])
	}
	rows := v.(*[]driver.Rows)
	if cap(*rows) >= len(data) {
		*rows = (*rows)[:len(data)]
	} else {
		*rows = make([]driver.Rows, len(data))
	}
	var firstErr error
	for i := range data {
		if err := c.dataGetStmtC(&((*rows)[i]), &data[i]); err != nil && firstErr == nil {
			firstErr = err
		}
	}
	return firstErr
}

func (c *conn) dataGetStmtC(row *driver.Rows, data * /*line :1729:53*/_Ctype_dpiData /*line :1729:62*/) error {
	if data.isNull == 1 {
		*row = nil
		return nil
	}
	st := &statement{conn: c, dpiStmt: ( /*line :1734:37*/_Cfunc_dpiData_getStmt /*line :1734:53*/)(data)}

	var n  /*line :1736:8*/_Ctype_uint32_t /*line :1736:18*/
	if func() _Ctype_int{ _cgo0 := /*line :1737:34*/st.dpiStmt; var _cgo1 *_Ctype_uint32_t = /*line :1737:46*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_getNumQueryColumns(_cgo0, _cgo1); }() == ( /*line :1737:53*/_Ciconst_DPI_FAILURE /*line :1737:65*/) {
		*row = &rows{
			err: errors.Errorf("getNumQueryColumns: %w: %w", c.getError(), io.EOF),
		}
		return nil
	}
	var err error
	*row, err = st.openRows(int(n))
	return err
}

func (c *conn) dataGetLOB(v interface{}, data [] /*line :1748:49*/_Ctype_dpiData /*line :1748:58*/) error {
	if L, ok := v.(*Lob); ok {
		if len(data) == 0 || data[0].isNull == 1 {
			*L = Lob{}
			return nil
		}
		c.dataGetLOBC(L, &data[0])
		return nil
	}
	slice := v.(*[]Lob)
	n := len(data)
	if cap(*slice) >= n {
		*slice = (*slice)[:n]
	} else {
		*slice = make([]Lob, n)
	}
	for i := range data {
		c.dataGetLOBC(&((*slice)[i]), &data[i])
	}
	return nil
}
func (c *conn) dataGetLOBC(L *Lob, data * /*line :1769:42*/_Ctype_dpiData /*line :1769:51*/) {
	L.Reader = nil
	if data.isNull == 1 {
		return
	}
	lob := ( /*line :1774:9*/_Cfunc_dpiData_getLOB /*line :1774:24*/)(data)
	if lob == nil {
		return
	}
	L.Reader = &dpiLobReader{conn: c, dpiLob: lob, IsClob: L.IsClob}
}

func (c *conn) dataSetLOB(dv * /*line :1781:31*/_Ctype_dpiVar /*line :1781:39*/, data [] /*line :1781:48*/_Ctype_dpiData /*line :1781:57*/, vv interface{}) error {
	if len(data) == 0 {
		return nil
	}
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}

	lobs := []Lob{{}}
	if L, ok := vv.(Lob); ok {
		lobs[0] = L
	} else {
		lobs = vv.([]Lob)
	}
	var firstErr error
	for i, L := range lobs {
		//fmt.Printf("dataSetLob[%d]=(%T) %#v\n", i, L, L)
		if L.Reader == nil {
			data[i].isNull = 1
			continue
		}
		data[i].isNull = 0
		if r, ok := L.Reader.(*dpiLobReader); ok {
			func() _Ctype_int{ _cgo0 := /*line :1804:24*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i); _cgo2 := /*line :1804:43*/r.dpiLob; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_dpiVar_setFromLob(_cgo0, _cgo1, _cgo2); }()
			continue
		}

		typ :=  /*line :1808:10*/_Ctype_dpiOracleTypeNum /*line :1808:28*/(( /*line :1808:29*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :1808:50*/))
		if L.IsClob {
			typ = ( /*line :1810:10*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :1810:31*/)
		}
		var lob * /*line :1812:12*/_Ctype_dpiLob /*line :1812:20*/
		if func() _Ctype_int{ _cgo0 := /*line :1813:27*/c.dpiConn; var _cgo1 _Ctype_dpiOracleTypeNum = /*line :1813:38*/typ; _cgoBase2 := /*line :1813:43*/&lob; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_dpiConn_newTempLob(_cgo0, _cgo1, _cgo2); }() == ( /*line :1813:52*/_Ciconst_DPI_FAILURE /*line :1813:64*/) {
			return errors.Errorf("newTempLob(typ=%d): %w", typ, c.getError())
		}
		var chunkSize  /*line :1816:17*/_Ctype_uint32_t /*line :1816:27*/
		_ = func() _Ctype_int{ _cgo0 := /*line :1817:29*/lob; var _cgo1 *_Ctype_uint32_t = /*line :1817:34*/&chunkSize; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_getChunkSize(_cgo0, _cgo1); }()
		if chunkSize == 0 {
			chunkSize = 8192
		}
		for chunkSize < minChunkSize {
			chunkSize <<= 1
		}
		lw := &dpiLobWriter{dpiLob: lob, conn: c, isClob: L.IsClob}
		_, err := io.CopyBuffer(lw, L, make([]byte, int(chunkSize)))
		//fmt.Printf("%p written %d with chunkSize=%d\n", lob, n, chunkSize)
		if closeErr := lw.Close(); closeErr != nil {
			if err == nil {
				err = closeErr
			}
			//fmt.Printf("close %p: %+v\n", lob, closeErr)
		}
		func() _Ctype_int{ _cgo0 := /*line :1833:23*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i); _cgo2 := /*line :1833:42*/lob; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_dpiVar_setFromLob(_cgo0, _cgo1, _cgo2); }()
		if err != nil && firstErr == nil {
			firstErr = err
		}
	}
	return firstErr
}

type userType interface {
	ObjectRef() *Object
}

// ObjectScanner assigns a value from a database object
type ObjectScanner interface {
	sql.Scanner
	userType
}

// ObjectWriter update database object before binding
type ObjectWriter interface {
	WriteObject() error
	userType
}

func (c *conn) dataSetObject(dv * /*line :1857:34*/_Ctype_dpiVar /*line :1857:42*/, data [] /*line :1857:51*/_Ctype_dpiData /*line :1857:60*/, vv interface{}) error {
	//fmt.Printf("\ndataSetObject(dv=%+v, data=%+v, vv=%+v)\n", dv, data, vv)
	if len(data) == 0 {
		return nil
	}
	if vv == nil {
		return dataSetNull(dv, data, nil)
	}
	objs := []Object{{}}
	switch o := vv.(type) {
	case Object:
		objs[0] = o
	case *Object:
		objs[0] = *o
	case []Object:
		objs = o
	case []*Object:
		objs = make([]Object, len(o))
		for i, x := range o {
			objs[i] = *x
		}
	case ObjectWriter:
		err := o.WriteObject()
		if err != nil {
			return err
		}
		objs[0] = *o.ObjectRef()
	case []ObjectWriter:
		for _, ut := range o {
			err := ut.WriteObject()
			if err != nil {
				return err
			}
			objs = append(objs, *ut.ObjectRef())
		}
	case userType:
		objs[0] = *o.ObjectRef()
	case []userType:
		for _, ut := range o {
			objs = append(objs, *ut.ObjectRef())
		}
	}
	for i, obj := range objs {
		if obj.dpiObject == nil {
			data[i].isNull = 1
			continue
		}
		data[i].isNull = 0
		if func() _Ctype_int{ _cgo0 := /*line :1905:29*/dv; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i); _cgo2 := /*line :1905:48*/obj.dpiObject; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_dpiVar_setFromObject(_cgo0, _cgo1, _cgo2); }() == ( /*line :1905:66*/_Ciconst_DPI_FAILURE /*line :1905:78*/) {
			return errors.Errorf("setFromObject: %w", c.getError())
		}
	}
	return nil
}

func (c *conn) dataGetObject(v interface{}, data [] /*line :1912:52*/_Ctype_dpiData /*line :1912:61*/) error {
	switch out := v.(type) {
	case *Object:
		d := Data{
			ObjectType: out.ObjectType,
			dpiData:    &data[0],
		}
		*out = *d.GetObject()
	case ObjectScanner:
		d := Data{
			ObjectType: out.ObjectRef().ObjectType,
			dpiData:    &data[0],
		}
		return out.Scan(d.GetObject())
	default:

		return fmt.Errorf("dataGetObject not implemented for type %T (maybe you need to implement the Scan method)", v)
	}

	return nil
}

// CheckNamedValue is called before passing arguments to the driver
// and is called in place of any ColumnConverter. CheckNamedValue must do type
// validation and conversion as appropriate for the driver.
//
// If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included
// in the final query arguments.
// This may be used to pass special options to the query itself.
//
// If ErrSkip is returned the column converter error checking path is used
// for the argument.
// Drivers may wish to return ErrSkip after they have exhausted their own special cases.
func (st *statement) CheckNamedValue(nv *driver.NamedValue) error {
	if nv == nil {
		return nil
	}
	if apply, ok := nv.Value.(Option); ok {
		if apply != nil {
			apply(&st.stmtOptions)
		}
		return driver.ErrRemoveArgument
	}
	return nil
}

// ColumnConverter may be optionally implemented by Stmt
// if the statement is aware of its own columns' types and
// can convert from any type to a driver Value.
func (st *statement) ColumnConverter(idx int) driver.ValueConverter {
	c := driver.ValueConverter(driver.DefaultParameterConverter)
	switch col := st.columns[idx]; col.OracleType {
	case ( /*line :1964:7*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :1964:30*/):
		switch col.NativeType {
		case ( /*line :1966:8*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :1966:30*/), ( /*line :1966:33*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :1966:56*/):
			c = Int64
		//case C.DPI_NATIVE_TYPE_FLOAT, C.DPI_NATIVE_TYPE_DOUBLE:
		//	c = Float64
		default:
			c = Num
		}
	}
	if Log != nil {
		Log("msg", "ColumnConverter", "c", c)
	}
	return driver.Null{Converter: c}
}

func (st *statement) openRows(colCount int) (*rows, error) {
	func() _Ctype_int{ _cgo0 := /*line :1981:30*/st.dpiStmt; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(st.FetchRowCount()); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_setFetchArraySize(_cgo0, _cgo1); }()

	r := rows{
		statement: st,
		columns:   make([]Column, colCount),
		vars:      make([]* /*line :1986:22*/_Ctype_dpiVar /*line :1986:30*/, colCount),
		data:      make([][] /*line :1987:23*/_Ctype_dpiData /*line :1987:32*/, colCount),
	}
	sliceLen := st.FetchRowCount()

	var info  /*line :1991:11*/_Ctype_dpiQueryInfo /*line :1991:25*/
	var ti  /*line :1992:9*/_Ctype_dpiDataTypeInfo /*line :1992:26*/
	for i := 0; i < colCount; i++ {
		if func() _Ctype_int{ _cgo0 := /*line :1994:29*/st.dpiStmt; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i + 1); _cgoBase2 := /*line :1994:58*/&info; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_dpiStmt_getQueryInfo(_cgo0, _cgo1, _cgo2); }() == ( /*line :1994:68*/_Ciconst_DPI_FAILURE /*line :1994:80*/) {
			return nil, errors.Errorf("getQueryInfo[%d]: %w", i, st.getError())
		}
		ti = info.typeInfo
		bufSize := int(ti.clientSizeInBytes)
		//if Log != nil {Log("msg", "openRows", "col", i, "info", ti) }
		//if Log != nil {Log("dNTN", int(ti.defaultNativeTypeNum), "number", C.DPI_ORACLE_TYPE_NUMBER) }
		switch ti.oracleTypeNum {
		case ( /*line :2002:8*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :2002:31*/):
			switch ti.defaultNativeTypeNum {
			case ( /*line :2004:9*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :2004:31*/), ( /*line :2004:34*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :2004:57*/):
				ti.defaultNativeTypeNum = ( /*line :2005:31*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :2005:53*/)
				bufSize = 40
			}
		case ( /*line :2008:8*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :2008:29*/):
			ti.defaultNativeTypeNum = ( /*line :2009:30*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :2009:56*/)

		case ( /*line :2011:8*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :2011:29*/):
			if !st.LobAsReader() {
				ti.oracleTypeNum = ( /*line :2013:24*/_Ciconst_DPI_ORACLE_TYPE_LONG_RAW /*line :2013:49*/)
				ti.defaultNativeTypeNum = ( /*line :2014:31*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :2014:53*/)
			}
		case ( /*line :2016:8*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :2016:29*/):
			if !st.LobAsReader() {
				ti.oracleTypeNum = ( /*line :2018:24*/_Ciconst_DPI_ORACLE_TYPE_LONG_VARCHAR /*line :2018:53*/)
				ti.defaultNativeTypeNum = ( /*line :2019:31*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :2019:53*/)
			}
		}
		r.columns[i] = Column{
			Name:        ( /*line :2023:17*/_Cfunc_GoStringN /*line :2023:27*/)(info.name,  /*line :2023:40*/_Ctype_int /*line :2023:45*/(info.nameLength)),
			OracleType:  ti.oracleTypeNum,
			NativeType:  ti.defaultNativeTypeNum,
			Size:        ti.clientSizeInBytes,
			Precision:   ti.precision,
			Scale:       ti.scale,
			Nullable:    info.nullOk == 1,
			ObjectType:  ti.objectType,
			SizeInChars: ti.sizeInChars,
			DBSize:      ti.dbSizeInBytes,
		}
		var err error
		//fmt.Printf("%d. %+v\n", i, r.columns[i])
		vi := varInfo{
			Typ:        ti.oracleTypeNum,
			NatTyp:     ti.defaultNativeTypeNum,
			ObjectType: ti.objectType,
			BufSize:    bufSize,
			SliceLen:   sliceLen,
		}
		if r.vars[i], r.data[i], err = st.newVar(vi); err != nil {
			return nil, err
		}

		if func() _Ctype_int{ _cgo0 := /*line :2047:23*/st.dpiStmt; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t(i + 1); _cgo2 := /*line :2047:52*/r.vars[i]; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_dpiStmt_define(_cgo0, _cgo1, _cgo2); }() == ( /*line :2047:66*/_Ciconst_DPI_FAILURE /*line :2047:78*/) {
			return nil, errors.Errorf("define[%d]: %w", i, st.getError())
		}
	}
	if func() _Ctype_int{ _cgo0 := /*line :2051:22*/st.dpiStmt; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiStmt_addRef(_cgo0); }() == ( /*line :2051:37*/_Ciconst_DPI_FAILURE /*line :2051:49*/) {
		return &r, errors.Errorf("dpiStmt_addRef: %w", st.getError())
	}
	st.columns = r.columns
	return &r, nil
}

// Column holds the info from a column.
type Column struct {
	Name                      string
	ObjectType                * /*line :2061:29*/_Ctype_dpiObjectType /*line :2061:44*/
	OracleType                 /*line :2062:28*/_Ctype_dpiOracleTypeNum /*line :2062:46*/
	NativeType                 /*line :2063:28*/_Ctype_dpiNativeTypeNum /*line :2063:46*/
	Size, SizeInChars, DBSize  /*line :2064:28*/_Ctype_uint32_t /*line :2064:38*/
	Precision                  /*line :2065:28*/_Ctype_int16_t /*line :2065:37*/
	Scale                      /*line :2066:28*/_Ctype_int8_t /*line :2066:36*/
	Nullable                  bool
}
