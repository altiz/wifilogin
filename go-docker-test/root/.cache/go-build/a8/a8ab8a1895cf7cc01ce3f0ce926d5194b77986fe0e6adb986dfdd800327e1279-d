// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/conn.go:1:1
// Copyright 2019 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"io"
	"strconv"
	"strings"
	"sync"
	"time"
	"unsafe"

	errors "golang.org/x/xerrors"
)

const getConnection = "--GET_CONNECTION--"
const wrapResultset = "--WRAP_RESULTSET--"

// The maximum capacity is limited to (2^32 / sizeof(dpiData))-1 to remain compatible
// with 32-bit platforms. The size of a `C.dpiData` is 32 Byte on a 64-bit system, `C.dpiSubscrMessageTable` is 40 bytes.
// So this is 2^25.
// See https://github.com/go-goracle/goracle/issues/73#issuecomment-401281714
const maxArraySize = (1<<32)/( /*line :35:30*/_Ciconst_sizeof_dpiSubscrMessageTable /*line :35:59*/) - 1

var _ = driver.Conn((*conn)(nil))
var _ = driver.ConnBeginTx((*conn)(nil))
var _ = driver.ConnPrepareContext((*conn)(nil))
var _ = driver.Pinger((*conn)(nil))

//var _ = driver.ExecerContext((*conn)(nil))

type conn struct {
	connParams     ConnectionParams
	currentTT      TraceTag
	Client, Server VersionInfo
	tranParams     tranParams
	sync.RWMutex
	currentUser string
	*drv
	dpiConn       * /*line :52:17*/_Ctype_dpiConn /*line :52:26*/
	inTransaction bool
	newSession    bool
	timeZone      *time.Location
	tzOffSecs     int
	objTypes      map[string]ObjectType
}

func (c *conn) getError() error {
	if c == nil || c.drv == nil {
		return driver.ErrBadConn
	}
	return c.drv.getError()
}

func (c *conn) Break() error {
	c.RLock()
	defer c.RUnlock()
	if Log != nil {
		Log("msg", "Break", "dpiConn", c.dpiConn)
	}
	if func() _Ctype_int{ _cgo0 := /*line :73:30*/c.dpiConn; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_breakExecution(_cgo0); }() == ( /*line :73:44*/_Ciconst_DPI_FAILURE /*line :73:56*/) {
		return maybeBadConn(errors.Errorf("Break: %w", c.getError()), c)
	}
	return nil
}

// Ping checks the connection's state.
//
// WARNING: as database/sql calls database/sql/driver.Open when it needs
// a new connection, but does not provide this Context,
// if the Open stalls (unreachable / firewalled host), the
// database/sql.Ping may return way after the Context.Deadline!
func (c *conn) Ping(ctx context.Context) error {
	if err := ctx.Err(); err != nil {
		return err
	}
	if err := c.ensureContextUser(ctx); err != nil {
		return err
	}
	c.RLock()
	defer c.RUnlock()
	done := make(chan error, 1)
	go func() {
		defer close(done)
		failure := func() _Ctype_int{ _cgo0 := /*line :97:29*/c.dpiConn; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_ping(_cgo0); }() == ( /*line :97:43*/_Ciconst_DPI_FAILURE /*line :97:55*/)
		if failure {
			done <- maybeBadConn(errors.Errorf("Ping: %w", c.getError()), c)
			return
		}
		done <- nil
	}()

	select {
	case err := <-done:
		return err
	case <-ctx.Done():
		// select again to avoid race condition if both are done
		select {
		case err := <-done:
			return err
		default:
			_ = c.Break()
			c.close(true)
			return driver.ErrBadConn
		}
	}
}

// Prepare returns a prepared statement, bound to this connection.
func (c *conn) Prepare(query string) (driver.Stmt, error) {
	return c.PrepareContext(context.Background(), query)
}

// Close invalidates and potentially stops any current
// prepared statements and transactions, marking this
// connection as no longer in use.
//
// Because the sql package maintains a free pool of
// connections and only calls Close when there's a surplus of
// idle connections, it shouldn't be necessary for drivers to
// do their own connection caching.
func (c *conn) Close() error {
	if c == nil {
		return nil
	}
	c.Lock()
	defer c.Unlock()
	return c.close(true)
}

func (c *conn) close(doNotReuse bool) error {
	if c == nil {
		return nil
	}
	c.setTraceTag(TraceTag{})
	dpiConn, objTypes := c.dpiConn, c.objTypes
	c.dpiConn, c.objTypes = nil, nil
	if dpiConn == nil {
		return nil
	}
	defer func() func() { _cgo0 := /*line :153:26*/dpiConn; return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_dpiConn_release(_cgo0); }}()()

	seen := make(map[string]struct{}, len(objTypes))
	for _, o := range objTypes {
		nm := o.FullName()
		if _, seen := seen[nm]; seen {
			continue
		}
		seen[nm] = struct{}{}
		o.close()
	}
	if !doNotReuse {
		return nil
	}

	// Just to be sure, break anything in progress.
	done := make(chan struct{})
	go func() {
		select {
		case <-done:
		case <-time.After(10 * time.Second):
			if Log != nil {
				Log("msg", "TIMEOUT releasing connection")
			}
			func() _Ctype_int{ _cgo0 := /*line :177:29*/dpiConn; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_breakExecution(_cgo0); }()
		}
	}()
	func() _Ctype_int{ _cgo0 := /*line :180:18*/dpiConn; var _cgo1 _Ctype_dpiConnCloseMode = /*line :180:27*/_Ciconst_DPI_MODE_CONN_CLOSE_DROP; var _cgo2 *_Ctype_char = /*line :180:55*/nil; var _cgo3 _Ctype_uint32_t = /*line :180:60*/0; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_close(_cgo0, _cgo1, _cgo2, _cgo3); }()
	close(done)
	return nil
}

// Begin starts and returns a new transaction.
//
// Deprecated: Drivers should implement ConnBeginTx instead (or additionally).
func (c *conn) Begin() (driver.Tx, error) {
	return c.BeginTx(context.Background(), driver.TxOptions{})
}

// BeginTx starts and returns a new transaction.
// If the context is canceled by the user the sql package will
// call Tx.Rollback before discarding and closing the connection.
//
// This must check opts.Isolation to determine if there is a set
// isolation level. If the driver does not support a non-default
// level and one is set or if there is a non-default isolation level
// that is not supported, an error must be returned.
//
// This must also check opts.ReadOnly to determine if the read-only
// value is true to either set the read-only transaction property if supported
// or return an error if it is not supported.
func (c *conn) BeginTx(ctx context.Context, opts driver.TxOptions) (driver.Tx, error) {
	if err := ctx.Err(); err != nil {
		return nil, err
	}

	const (
		trRO = "READ ONLY"
		trRW = "READ WRITE"
		trLC = "ISOLATION LEVEL READ COMMIT" + "TED" // against misspell check
		trLS = "ISOLATION LEVEL SERIALIZABLE"
	)

	var todo tranParams
	if opts.ReadOnly {
		todo.RW = trRO
	} else {
		todo.RW = trRW
	}
	switch level := sql.IsolationLevel(opts.Isolation); level {
	case sql.LevelDefault:
	case sql.LevelReadCommitted:
		todo.Level = trLC
	case sql.LevelSerializable:
		todo.Level = trLS
	default:
		return nil, errors.Errorf("isolation level is not supported: %s", sql.IsolationLevel(opts.Isolation))
	}

	if todo != c.tranParams {
		for _, qry := range []string{todo.RW, todo.Level} {
			if qry == "" {
				continue
			}
			qry = "SET TRANSACTION " + qry
			stmt, err := c.PrepareContext(ctx, qry)
			if err == nil {
				if stc, ok := stmt.(driver.StmtExecContext); ok {
					_, err = stc.ExecContext(ctx, nil)
				} else {
					_, err = stmt.Exec(nil) //lint:ignore SA1019 as that comment is not relevant here
				}
				stmt.Close()
			}
			if err != nil {
				return nil, maybeBadConn(errors.Errorf("%s: %w", qry, err), c)
			}
		}
		c.tranParams = todo
	}

	c.RLock()
	inTran := c.inTransaction
	c.RUnlock()
	if inTran {
		return nil, errors.New("already in transaction")
	}
	c.Lock()
	c.inTransaction = true
	c.Unlock()
	if tt, ok := ctx.Value(traceTagCtxKey).(TraceTag); ok {
		c.Lock()
		c.setTraceTag(tt)
		c.Unlock()
	}
	return c, nil
}

type tranParams struct {
	RW, Level string
}

// PrepareContext returns a prepared statement, bound to this connection.
// context is for the preparation of the statement,
// it must not store the context within the statement itself.
func (c *conn) PrepareContext(ctx context.Context, query string) (driver.Stmt, error) {
	if err := ctx.Err(); err != nil {
		return nil, err
	}
	if err := c.ensureContextUser(ctx); err != nil {
		return nil, err
	}
	if tt, ok := ctx.Value(traceTagCtxKey).(TraceTag); ok {
		c.Lock()
		c.setTraceTag(tt)
		c.Unlock()
	}
	if query == getConnection {
		if Log != nil {
			Log("msg", "PrepareContext", "shortcut", query)
		}
		return &statement{conn: c, query: query}, nil
	}

	cSQL := ( /*line :297:10*/_Cfunc_CString /*line :297:18*/)(query)
	defer func() {
		func() { _cgo0 := /*line :299:10*/unsafe.Pointer(cSQL); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
	}()
	c.RLock()
	defer c.RUnlock()
	var dpiStmt * /*line :303:15*/_Ctype_dpiStmt /*line :303:24*/
	if func() _Ctype_int{ _cgo0 := /*line :304:27*/c.dpiConn; var _cgo1 _Ctype_int = /*line :304:38*/0; var _cgo2 *_Ctype_char = /*line :304:41*/cSQL; var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t(len(query)); var _cgo4 *_Ctype_char = /*line :304:71*/nil; var _cgo5 _Ctype_uint32_t = /*line :304:76*/0; _cgoBase6 := /*line :305:32*/&dpiStmt; _cgo6 := /*line :305:3*/(**_Ctype_dpiStmt)(unsafe.Pointer(_cgoBase6)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase6, 0 == 0); return _Cfunc_dpiConn_prepareStmt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }() == ( /*line :306:7*/_Ciconst_DPI_FAILURE /*line :306:19*/) {
		return nil, maybeBadConn(errors.Errorf("Prepare: %s: %w", query, c.getError()), c)
	}
	return &statement{conn: c, dpiStmt: dpiStmt, query: query}, nil
}
func (c *conn) Commit() error {
	return c.endTran(true)
}
func (c *conn) Rollback() error {
	return c.endTran(false)
}
func (c *conn) endTran(isCommit bool) error {
	c.Lock()
	c.inTransaction = false
	c.tranParams = tranParams{}

	var err error
	//msg := "Commit"
	if isCommit {
		if func() _Ctype_int{ _cgo0 := /*line :325:23*/c.dpiConn; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_commit(_cgo0); }() == ( /*line :325:37*/_Ciconst_DPI_FAILURE /*line :325:49*/) {
			err = maybeBadConn(errors.Errorf("Commit: %w", c.getError()), c)
		}
	} else {
		//msg = "Rollback"
		if func() _Ctype_int{ _cgo0 := /*line :330:25*/c.dpiConn; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_rollback(_cgo0); }() == ( /*line :330:39*/_Ciconst_DPI_FAILURE /*line :330:51*/) {
			err = maybeBadConn(errors.Errorf("Rollback: %w", c.getError()), c)
		}
	}
	c.Unlock()
	//fmt.Printf("%p.%s\n", c, msg)
	return err
}

type varInfo struct {
	SliceLen, BufSize int
	ObjectType        * /*line :341:21*/_Ctype_dpiObjectType /*line :341:36*/
	NatTyp             /*line :342:20*/_Ctype_dpiNativeTypeNum /*line :342:38*/
	Typ                /*line :343:20*/_Ctype_dpiOracleTypeNum /*line :343:38*/
	IsPLSArray        bool
}

func (c *conn) newVar(vi varInfo) (* /*line :347:37*/_Ctype_dpiVar /*line :347:45*/, [] /*line :347:49*/_Ctype_dpiData /*line :347:58*/, error) {
	if c == nil || c.dpiConn == nil {
		return nil, nil, errors.New("connection is nil")
	}
	isArray :=  /*line :351:13*/_Ctype_int /*line :351:18*/(0)
	if vi.IsPLSArray {
		isArray = 1
	}
	if vi.SliceLen < 1 {
		vi.SliceLen = 1
	}
	var dataArr * /*line :358:15*/_Ctype_dpiData /*line :358:24*/
	var v * /*line :359:9*/_Ctype_dpiVar /*line :359:17*/
	if Log != nil {
		Log("C", "dpiConn_newVar", "conn", c.dpiConn, "typ", int(vi.Typ), "natTyp", int(vi.NatTyp), "sliceLen", vi.SliceLen, "bufSize", vi.BufSize, "isArray", isArray, "objType", vi.ObjectType, "v", v)
	}
	if func() _Ctype_int{ _cgo0 := /*line :364:3*/c.dpiConn; var _cgo1 _Ctype_dpiOracleTypeNum = /*line :364:14*/vi.Typ; var _cgo2 _Ctype_dpiNativeTypeNum = /*line :364:22*/vi.NatTyp; var _cgo3 _Ctype_uint32_t = _Ctype_uint32_t(vi.SliceLen); var _cgo4 _Ctype_uint32_t = _Ctype_uint32_t(vi.BufSize); var _cgo5 _Ctype_int = /*line :365:27*/1; var _cgo6 _Ctype_int = /*line :366:3*/isArray; _cgo7 := /*line :366:12*/vi.ObjectType; _cgoBase8 := /*line :367:3*/&v; _cgo8 := _cgoBase8; _cgoBase9 := /*line :367:7*/&dataArr; _cgo9 := _cgoBase9; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo7, nil); _cgoCheckPointer(_cgoBase8, 0 == 0); _cgoCheckPointer(_cgoBase9, 0 == 0); return _Cfunc_dpiConn_newVar(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8, _cgo9); }() == ( /*line :368:7*/_Ciconst_DPI_FAILURE /*line :368:19*/) {
		return nil, nil, errors.Errorf("newVar(typ=%d, natTyp=%d, sliceLen=%d, bufSize=%d): %w", vi.Typ, vi.NatTyp, vi.SliceLen, vi.BufSize, c.getError())
	}
	// https://github.com/golang/go/wiki/cgo#Turning_C_arrays_into_Go_slices
	/*
		var theCArray *C.YourType = C.getTheArray()
		length := C.getTheArrayLength()
		slice := (*[maxArraySize]C.YourType)(unsafe.Pointer(theCArray))[:length:length]
	*/
	data := ((*[maxArraySize] /*line :377:27*/_Ctype_dpiData /*line :377:36*/)(unsafe.Pointer(dataArr)))[:vi.SliceLen:vi.SliceLen]
	return v, data, nil
}

var _ = driver.Tx((*conn)(nil))

func (c *conn) ServerVersion() (VersionInfo, error) {
	return c.Server, nil
}

func (c *conn) init() error {
	if c.Client.Version == 0 {
		var err error
		if c.Client, err = c.drv.ClientVersion(); err != nil {
			return err
		}
	}
	if c.Server.Version == 0 {
		var v  /*line :395:9*/_Ctype_dpiVersionInfo /*line :395:25*/
		var release * /*line :396:16*/_Ctype_char /*line :396:22*/
		var releaseLen  /*line :397:18*/_Ctype_uint32_t /*line :397:28*/
		if func() _Ctype_int{ _cgo0 := /*line :398:33*/c.dpiConn; _cgoBase1 := /*line :398:44*/&release; _cgo1 := _cgoBase1; var _cgo2 *_Ctype_uint32_t = /*line :398:54*/&releaseLen; var _cgo3 *_Ctype_struct_dpiVersionInfo = /*line :398:67*/&v; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_dpiConn_getServerVersion(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :398:74*/_Ciconst_DPI_FAILURE /*line :398:86*/) {
			if c.connParams.IsPrelim {
				return nil
			}
			return errors.Errorf("getServerVersion: %w", c.getError())
		}
		c.Server.set(&v)
		c.Server.ServerRelease = string(bytesReplaceAll(
			((*[maxArraySize]byte)(unsafe.Pointer(release)))[:releaseLen:releaseLen],
			[]byte{'\n'}, []byte{';', ' '}))
	}

	if c.timeZone != nil && (c.timeZone != time.Local || c.tzOffSecs != 0) {
		return nil
	}
	c.timeZone = time.Local
	_, c.tzOffSecs = time.Now().In(c.timeZone).Zone()
	if Log != nil {
		Log("tz", c.timeZone, "offSecs", c.tzOffSecs)
	}

	// DBTIMEZONE is useless, false, and misdirecting!
	// https://stackoverflow.com/questions/52531137/sysdate-and-dbtimezone-different-in-oracle-database
	const qry = "SELECT DBTIMEZONE, LTRIM(REGEXP_SUBSTR(TO_CHAR(SYSTIMESTAMP), ' [^ ]+$')) FROM DUAL"
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
	defer cancel()
	st, err := c.PrepareContext(ctx, qry)
	if err != nil {
		return errors.Errorf("%s: %w", qry, err)
	}
	defer st.Close()
	rows, err := st.Query(nil) //lint:ignore SA1019 - it's hard to use QueryContext here
	if err != nil {
		if Log != nil {
			Log("qry", qry, "error", err)
		}
		return nil
	}
	defer rows.Close()
	var dbTZ, timezone string
	vals := []driver.Value{dbTZ, timezone}
	if err = rows.Next(vals); err != nil && err != io.EOF {
		return errors.Errorf("%s: %w", qry, err)
	}
	dbTZ = vals[0].(string)
	timezone = vals[1].(string)

	tz, off, err := calculateTZ(dbTZ, timezone)
	if Log != nil {
		Log("timezone", timezone, "tz", tz, "offSecs", off)
	}
	if err != nil || tz == nil {
		return err
	}
	c.timeZone, c.tzOffSecs = tz, off

	return nil
}

func calculateTZ(dbTZ, timezone string) (*time.Location, int, error) {
	if Log != nil {
		Log("dbTZ", dbTZ, "timezone", timezone)
	}
	var tz *time.Location
	now := time.Now()
	_, localOff := time.Now().Local().Zone()
	off := localOff
	var ok bool
	var err error
	if dbTZ != "" && strings.Contains(dbTZ, "/") {
		tz, err = time.LoadLocation(dbTZ)
		if ok = err == nil; ok {
			if tz == time.Local {
				return tz, off, nil
			}
			_, off = now.In(tz).Zone()
		} else if Log != nil {
			Log("LoadLocation", dbTZ, "error", err)
		}
	}
	if !ok {
		if timezone != "" {
			if off, err = parseTZ(timezone); err != nil {
				return tz, off, errors.Errorf("%s: %w", timezone, err)
			}
		} else if off, err = parseTZ(dbTZ); err != nil {
			return tz, off, errors.Errorf("%s: %w", dbTZ, err)
		}
	}
	// This is dangerous, but I just cannot get whether the DB time zone
	// setting has DST or not - DBTIMEZONE returns just a fixed offset.
	if off != localOff && tz == nil {
		tz = time.FixedZone(timezone, off)
	}
	return tz, off, nil
}
func parseTZ(s string) (int, error) {
	s = strings.TrimSpace(s)
	if s == "" {
		return 0, io.EOF
	}
	if s == "Z" || s == "UTC" {
		return 0, nil
	}
	var tz int
	var ok bool
	if i := strings.IndexByte(s, ':'); i >= 0 {
		if i64, err := strconv.ParseInt(s[i+1:], 10, 6); err != nil {
			return tz, errors.Errorf("%s: %w", s, err)
		} else {
			tz = int(i64 * 60)
		}
		s = s[:i]
		ok = true
	}
	if !ok {
		if i := strings.IndexByte(s, '/'); i >= 0 {
			targetLoc, err := time.LoadLocation(s)
			if err != nil {
				return tz, errors.Errorf("%s: %w", s, err)
			}

			_, localOffset := time.Now().In(targetLoc).Zone()

			tz = localOffset
			return tz, nil
		}
	}
	if i64, err := strconv.ParseInt(s, 10, 5); err != nil {
		return tz, errors.Errorf("%s: %w", s, err)
	} else {
		if i64 < 0 {
			tz = -tz
		}
		tz += int(i64 * 3600)
	}
	return tz, nil
}

func (c *conn) setCallTimeout(ctx context.Context) {
	if c.Client.Version < 18 {
		return
	}
	var ms  /*line :541:9*/_Ctype_uint32_t /*line :541:19*/
	if dl, ok := ctx.Deadline(); ok {
		ms =  /*line :543:8*/_Ctype_uint32_t /*line :543:18*/(time.Until(dl) / time.Millisecond)
	}
	// force it to be 0 (disabled)
	func() _Ctype_int{ _cgo0 := /*line :546:27*/c.dpiConn; var _cgo1 _Ctype_uint32_t = /*line :546:38*/ms; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setCallTimeout(_cgo0, _cgo1); }()
}

// maybeBadConn checks whether the error is because of a bad connection, and returns driver.ErrBadConn,
// as database/sql requires.
//
// Also in this case, iff c != nil, closes it.
func maybeBadConn(err error, c *conn) error {
	if err == nil {
		return nil
	}
	cl := func() {}
	if c != nil {
		cl = func() {
			if Log != nil {
				Log("msg", "maybeBadConn close", "conn", c)
			}
			c.close(true)
		}
	}
	if errors.Is(err, driver.ErrBadConn) {
		cl()
		return driver.ErrBadConn
	}
	var cd interface{ Code() int }
	if errors.As(err, &cd) {
		// Yes, this is copied from rana/ora, but I've put it there, so it's mine. @tgulacsi
		switch cd.Code() {
		case 0:
			if strings.Contains(err.Error(), " DPI-1002: ") {
				cl()
				return driver.ErrBadConn
			}
			// cases by experience:
			// ORA-12170: TNS:Connect timeout occurred
			// ORA-12528: TNS:listener: all appropriate instances are blocking new connections
			// ORA-12545: Connect failed because target host or object does not exist
			// ORA-24315: illegal attribute type
			// ORA-28547: connection to server failed, probable Oracle Net admin error
		case 12170, 12528, 12545, 24315, 28547:

			//cases from https://github.com/oracle/odpi/blob/master/src/dpiError.c#L61-L94
		case 22, // invalid session ID; access denied
			28,    // your session has been killed
			31,    // your session has been marked for kill
			45,    // your session has been terminated with no replay
			378,   // buffer pools cannot be created as specified
			602,   // internal programming exception
			603,   // ORACLE server session terminated by fatal error
			609,   // could not attach to incoming connection
			1012,  // not logged on
			1041,  // internal error. hostdef extension doesn't exist
			1043,  // user side memory corruption
			1089,  // immediate shutdown or close in progress
			1092,  // ORACLE instance terminated. Disconnection forced
			2396,  // exceeded maximum idle time, please connect again
			3113,  // end-of-file on communication channel
			3114,  // not connected to ORACLE
			3122,  // attempt to close ORACLE-side window on user side
			3135,  // connection lost contact
			3136,  // inbound connection timed out
			12153, // TNS:not connected
			12537, // TNS:connection closed
			12547, // TNS:lost contact
			12570, // TNS:packet reader failure
			12583, // TNS:no reader
			27146, // post/wait initialization failed
			28511, // lost RPC connection
			56600: // an illegal OCI function call was issued
			cl()
			return driver.ErrBadConn
		}
	}
	return err
}

func (c *conn) setTraceTag(tt TraceTag) error {
	if c == nil || c.dpiConn == nil {
		return nil
	}
	for nm, vv := range map[string][2]string{
		"action":     {c.currentTT.Action, tt.Action},
		"module":     {c.currentTT.Module, tt.Module},
		"info":       {c.currentTT.ClientInfo, tt.ClientInfo},
		"identifier": {c.currentTT.ClientIdentifier, tt.ClientIdentifier},
		"op":         {c.currentTT.DbOp, tt.DbOp},
	} {
		if vv[0] == vv[1] {
			continue
		}
		v := vv[1]
		var s * /*line :637:10*/_Ctype_char /*line :637:16*/
		if v != "" {
			s = ( /*line :639:8*/_Cfunc_CString /*line :639:16*/)(v)
		}
		var rc  /*line :641:10*/_Ctype_int /*line :641:15*/
		switch nm {
		case "action":
			rc = func() _Ctype_int{ _cgo0 := /*line :644:29*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :644:40*/s; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(v)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setAction(_cgo0, _cgo1, _cgo2); }()
		case "module":
			rc = func() _Ctype_int{ _cgo0 := /*line :646:29*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :646:40*/s; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(v)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setModule(_cgo0, _cgo1, _cgo2); }()
		case "info":
			rc = func() _Ctype_int{ _cgo0 := /*line :648:33*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :648:44*/s; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(v)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setClientInfo(_cgo0, _cgo1, _cgo2); }()
		case "identifier":
			rc = func() _Ctype_int{ _cgo0 := /*line :650:39*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :650:50*/s; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(v)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setClientIdentifier(_cgo0, _cgo1, _cgo2); }()
		case "op":
			rc = func() _Ctype_int{ _cgo0 := /*line :652:27*/c.dpiConn; var _cgo1 *_Ctype_char = /*line :652:38*/s; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t(len(v)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_setDbOp(_cgo0, _cgo1, _cgo2); }()
		}
		if s != nil {
			func() { _cgo0 := /*line :655:11*/unsafe.Pointer(s); _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }()
		}
		if rc == ( /*line :657:12*/_Ciconst_DPI_FAILURE /*line :657:24*/) {
			return errors.Errorf("%s: %w", nm, c.getError())
		}
	}
	c.currentTT = tt
	return nil
}

const traceTagCtxKey = ctxKey("tracetag")

// ContextWithTraceTag returns a context with the specified TraceTag, which will
// be set on the session used.
func ContextWithTraceTag(ctx context.Context, tt TraceTag) context.Context {
	return context.WithValue(ctx, traceTagCtxKey, tt)
}

// TraceTag holds tracing information for the session. It can be set on the session
// with ContextWithTraceTag.
type TraceTag struct {
	// ClientIdentifier - specifies an end user based on the logon ID, such as HR.HR
	ClientIdentifier string
	// ClientInfo - client-specific info
	ClientInfo string
	// DbOp - database operation
	DbOp string
	// Module - specifies a functional block, such as Accounts Receivable or General Ledger, of an application
	Module string
	// Action - specifies an action, such as an INSERT or UPDATE operation, in a module
	Action string
}

const userpwCtxKey = ctxKey("userPw")

// ContextWithUserPassw returns a context with the specified user and password,
// to be used with heterogeneous pools.
func ContextWithUserPassw(ctx context.Context, user, password string) context.Context {
	return context.WithValue(ctx, userpwCtxKey, [2]string{user, password})
}

func (c *conn) ensureContextUser(ctx context.Context) error {
	if !c.connParams.HeterogeneousPool {
		return nil
	}

	var up [2]string
	var ok bool
	if up, ok = ctx.Value(userpwCtxKey).([2]string); !ok || up[0] == c.currentUser {
		return nil
	}

	if c.dpiConn != nil {
		if err := c.close(false); err != nil {
			return driver.ErrBadConn
		}
	}

	c.Lock()
	defer c.Unlock()

	if err := c.acquireConn(up[0], up[1]); err != nil {
		return err
	}

	return c.init()
}

// StartupMode for the database.
type StartupMode  /*line :724:18*/_Ctype_dpiStartupMode /*line :724:34*/

const (
	// StartupDefault is the default mode for startup which permits database access to all users.
	StartupDefault = StartupMode(( /*line :728:31*/_Ciconst_DPI_MODE_STARTUP_DEFAULT /*line :728:56*/))
	// StartupForce shuts down a running instance (using ABORT) before starting a new one. This mode should only be used in unusual circumstances.
	StartupForce = StartupMode(( /*line :730:29*/_Ciconst_DPI_MODE_STARTUP_FORCE /*line :730:52*/))
	// StartupRestrict only allows database access to users with both the CREATE SESSION and RESTRICTED SESSION privileges (normally the DBA).
	StartupRestrict = StartupMode(( /*line :732:32*/_Ciconst_DPI_MODE_STARTUP_RESTRICT /*line :732:58*/))
)

// Startup the database, equivalent to "startup nomount" in SQL*Plus.
// This should be called on PRELIM_AUTH (prelim=1) connection!
//
// See https://docs.oracle.com/en/database/oracle/oracle-database/18/lnoci/database-startup-and-shutdown.html#GUID-44B24F65-8C24-4DF3-8FBF-B896A4D6F3F3
func (c *conn) Startup(mode StartupMode) error {
	if func() _Ctype_int{ _cgo0 := /*line :740:31*/c.dpiConn; var _cgo1 _Ctype_dpiStartupMode = _Ctype_dpiStartupMode(mode); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_startupDatabase(_cgo0, _cgo1); }() == ( /*line :740:69*/_Ciconst_DPI_FAILURE /*line :740:81*/) {
		return errors.Errorf("startup(%v): %w", mode, c.getError())
	}
	return nil
}

// ShutdownMode for the database.
type ShutdownMode  /*line :747:19*/_Ctype_dpiShutdownMode /*line :747:36*/

const (
	// ShutdownDefault - further connections to the database are prohibited. Wait for users to disconnect from the database.
	ShutdownDefault = ShutdownMode(( /*line :751:33*/_Ciconst_DPI_MODE_SHUTDOWN_DEFAULT /*line :751:59*/))
	// ShutdownTransactional - further connections to the database are prohibited and no new transactions are allowed to be started. Wait for active transactions to complete.
	ShutdownTransactional = ShutdownMode(( /*line :753:39*/_Ciconst_DPI_MODE_SHUTDOWN_TRANSACTIONAL /*line :753:71*/))
	// ShutdownTransactionalLocal - behaves the same way as ShutdownTransactional but only waits for local transactions to complete.
	ShutdownTransactionalLocal = ShutdownMode(( /*line :755:44*/_Ciconst_DPI_MODE_SHUTDOWN_TRANSACTIONAL_LOCAL /*line :755:82*/))
	// ShutdownImmediate - all uncommitted transactions are terminated and rolled back and all connections to the database are closed immediately.
	ShutdownImmediate = ShutdownMode(( /*line :757:35*/_Ciconst_DPI_MODE_SHUTDOWN_IMMEDIATE /*line :757:63*/))
	// ShutdownAbort - all uncommitted transactions are terminated and are not rolled back. This is the fastest way to shut down the database but the next database startup may require instance recovery.
	ShutdownAbort = ShutdownMode(( /*line :759:31*/_Ciconst_DPI_MODE_SHUTDOWN_ABORT /*line :759:55*/))
	// ShutdownFinal shuts down the database. This mode should only be used in the second call to dpiConn_shutdownDatabase().
	ShutdownFinal = ShutdownMode(( /*line :761:31*/_Ciconst_DPI_MODE_SHUTDOWN_FINAL /*line :761:55*/))
)

// Shutdown shuts down the database.
// Note that this must be done in two phases except in the situation where the instance is aborted.
//
// See https://docs.oracle.com/en/database/oracle/oracle-database/18/lnoci/database-startup-and-shutdown.html#GUID-44B24F65-8C24-4DF3-8FBF-B896A4D6F3F3
func (c *conn) Shutdown(mode ShutdownMode) error {
	if func() _Ctype_int{ _cgo0 := /*line :769:32*/c.dpiConn; var _cgo1 _Ctype_dpiShutdownMode = _Ctype_dpiShutdownMode(mode); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiConn_shutdownDatabase(_cgo0, _cgo1); }() == ( /*line :769:71*/_Ciconst_DPI_FAILURE /*line :769:83*/) {
		return errors.Errorf("shutdown(%v): %w", mode, c.getError())
	}
	return nil
}

// Timezone returns the connection's timezone.
func (c *conn) Timezone() *time.Location {
	return c.timeZone
}
