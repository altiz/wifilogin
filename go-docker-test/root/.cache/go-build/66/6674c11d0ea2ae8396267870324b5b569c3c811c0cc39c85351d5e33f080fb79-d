// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/data.go:1:1
// Copyright 2017 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include <stdlib.h>
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"reflect"
	"time"
	"unsafe"

	errors "golang.org/x/xerrors"
)

// Data holds the data to/from Oracle.
type Data struct {
	ObjectType    ObjectType
	dpiData       * /*line :27:17*/_Ctype_dpiData /*line :27:26*/
	NativeTypeNum  /*line :28:16*/_Ctype_dpiNativeTypeNum /*line :28:34*/
}

var ErrNotSupported = errors.New("not supported")

// NewData creates a new Data structure for the given type, populated with the given type.
func NewData(v interface{}) (*Data, error) {
	if v == nil {
		return nil, errors.Errorf("%s: %w", "nil type", ErrNotSupported)
	}
	data := Data{dpiData: & /*line :38:25*/_Ctype_dpiData /*line :38:34*/{isNull: 1}}
	return &data, data.Set(v)
}

// IsNull returns whether the data is null.
func (d *Data) IsNull() bool {
	// Use of C.dpiData_getIsNull(d.dpiData) would be safer,
	// but ODPI-C 3.1.4 just returns dpiData->isNull, so do the same
	// without calling CGO.
	return d == nil || d.dpiData == nil || d.dpiData.isNull == 1
}

// SetNull sets the value of the data to be the null value.
func (d *Data) SetNull() {
	if !d.IsNull() {
		// Maybe C.dpiData_setNull(d.dpiData) would be safer, but as we don't use C.dpiData_getIsNull,
		// and those functions (at least in ODPI-C 3.1.4) just operate on data->isNull directly,
		// don't use CGO if possible.
		d.dpiData.isNull = 1
	}
}

// GetBool returns the bool data.
func (d *Data) GetBool() bool {
	return !d.IsNull() && ( /*line :62:24*/_Cfunc_dpiData_getBool /*line :62:40*/)(d.dpiData) == 1
}

// SetBool sets the data as bool.
func (d *Data) SetBool(b bool) {
	var i  /*line :67:8*/_Ctype_int /*line :67:13*/
	if b {
		i = 1
	}
	( /*line :71:2*/_Cfunc_dpiData_setBool /*line :71:18*/)(d.dpiData, i)
}

// GetBytes returns the []byte from the data.
func (d *Data) GetBytes() []byte {
	if d.IsNull() {
		return nil
	}
	b := ( /*line :79:7*/_Cfunc_dpiData_getBytes /*line :79:24*/)(d.dpiData)
	if b.ptr == nil || b.length == 0 {
		return nil
	}
	return ((*[32767]byte)(unsafe.Pointer(b.ptr)))[:b.length:b.length]
}

// SetBytes set the data as []byte.
func (d *Data) SetBytes(b []byte) {
	if b == nil {
		d.dpiData.isNull = 1
		return
	}
	( /*line :92:2*/_Cfunc_dpiData_setBytes /*line :92:19*/)(d.dpiData, (* /*line :92:34*/_Ctype_char /*line :92:40*/)(unsafe.Pointer(&b[0])),  /*line :92:66*/_Ctype_uint32_t /*line :92:76*/(len(b)))
}

// GetFloat32 gets float32 from the data.
func (d *Data) GetFloat32() float32 {
	if d.IsNull() {
		return 0
	}
	return float32(( /*line :100:17*/_Cfunc_dpiData_getFloat /*line :100:34*/)(d.dpiData))
}

// SetFloat32 sets the data as float32.
func (d *Data) SetFloat32(f float32) {
	( /*line :105:2*/_Cfunc_dpiData_setFloat /*line :105:19*/)(d.dpiData,  /*line :105:32*/_Ctype_float /*line :105:39*/(f))
}

// GetFloat64 gets float64 from the data.
func (d *Data) GetFloat64() float64 {
	//fmt.Println("GetFloat64", d.IsNull(), d)
	if d.IsNull() {
		return 0
	}
	return float64(( /*line :114:17*/_Cfunc_dpiData_getDouble /*line :114:35*/)(d.dpiData))
}

// SetFloat64 sets the data as float64.
func (d *Data) SetFloat64(f float64) {
	( /*line :119:2*/_Cfunc_dpiData_setDouble /*line :119:20*/)(d.dpiData,  /*line :119:33*/_Ctype_double /*line :119:41*/(f))
}

// GetInt64 gets int64 from the data.
func (d *Data) GetInt64() int64 {
	if d.IsNull() {
		return 0
	}
	return int64(( /*line :127:15*/_Cfunc_dpiData_getInt64 /*line :127:32*/)(d.dpiData))
}

// SetInt64 sets the data as int64.
func (d *Data) SetInt64(i int64) {
	( /*line :132:2*/_Cfunc_dpiData_setInt64 /*line :132:19*/)(d.dpiData,  /*line :132:32*/_Ctype_int64_t /*line :132:41*/(i))
}

// GetIntervalDS gets duration as interval date-seconds from data.
func (d *Data) GetIntervalDS() time.Duration {
	if d.IsNull() {
		return 0
	}
	ds := ( /*line :140:8*/_Cfunc_dpiData_getIntervalDS /*line :140:30*/)(d.dpiData)
	return time.Duration(ds.days)*24*time.Hour +
		time.Duration(ds.hours)*time.Hour +
		time.Duration(ds.minutes)*time.Minute +
		time.Duration(ds.seconds)*time.Second +
		time.Duration(ds.fseconds)
}

// SetIntervalDS sets the duration as interval date-seconds to data.
func (d *Data) SetIntervalDS(dur time.Duration) {
	( /*line :150:2*/_Cfunc_dpiData_setIntervalDS /*line :150:24*/)(d.dpiData,
		 /*line :151:3*/_Ctype_int32_t /*line :151:12*/(int64(dur.Hours())/24),
		 /*line :152:3*/_Ctype_int32_t /*line :152:12*/(int64(dur.Hours())%24),  /*line :152:37*/_Ctype_int32_t /*line :152:46*/(dur.Minutes()),  /*line :152:63*/_Ctype_int32_t /*line :152:72*/(dur.Seconds()),
		 /*line :153:3*/_Ctype_int32_t /*line :153:12*/(dur.Nanoseconds()),
	)
}

// GetIntervalYM gets IntervalYM from the data.
func (d *Data) GetIntervalYM() IntervalYM {
	if d.IsNull() {
		return IntervalYM{}
	}
	ym := ( /*line :162:8*/_Cfunc_dpiData_getIntervalYM /*line :162:30*/)(d.dpiData)
	return IntervalYM{Years: int(ym.years), Months: int(ym.months)}
}

// SetIntervalYM sets IntervalYM to the data.
func (d *Data) SetIntervalYM(ym IntervalYM) {
	( /*line :168:2*/_Cfunc_dpiData_setIntervalYM /*line :168:24*/)(d.dpiData,  /*line :168:37*/_Ctype_int32_t /*line :168:46*/(ym.Years),  /*line :168:58*/_Ctype_int32_t /*line :168:67*/(ym.Months))
}

// GetLob gets data as Lob.
func (d *Data) GetLob() *Lob {
	if d.IsNull() {
		return nil
	}
	return &Lob{Reader: &dpiLobReader{dpiLob: ( /*line :176:44*/_Cfunc_dpiData_getLOB /*line :176:59*/)(d.dpiData)}}
}

// SetLob sets Lob to the data.
func (d *Data) SetLob(lob *DirectLob) {
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :181:19*/d.dpiData; _cgo1 := /*line :181:30*/lob.dpiLob; _cgoCheckPointer(_cgo1, nil); _Cfunc_dpiData_setLOB(_cgo0, _cgo1); }()
}

// GetObject gets Object from data.
//
// As with all Objects, you MUST call Close on it when not needed anymore!
func (d *Data) GetObject() *Object {
	if d == nil || d.dpiData == nil {
		panic("null")
	}
	if d.IsNull() {
		return nil
	}

	o := ( /*line :195:7*/_Cfunc_dpiData_getObject /*line :195:25*/)(d.dpiData)
	if o == nil {
		return nil
	}
	if func() _Ctype_int{ _cgo0 := /*line :199:24*/o; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiObject_addRef(_cgo0); }() == ( /*line :199:30*/_Ciconst_DPI_FAILURE /*line :199:42*/) {
		panic(d.ObjectType.getError())
	}
	obj := &Object{dpiObject: o, ObjectType: d.ObjectType}
	obj.init()
	return obj
}

// SetObject sets Object to data.
func (d *Data) SetObject(o *Object) {
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :209:22*/d.dpiData; _cgo1 := /*line :209:33*/o.dpiObject; _cgoCheckPointer(_cgo1, nil); _Cfunc_dpiData_setObject(_cgo0, _cgo1); }()
}

// GetStmt gets Stmt from data.
func (d *Data) GetStmt() driver.Stmt {
	if d.IsNull() {
		return nil
	}
	return &statement{dpiStmt: ( /*line :217:29*/_Cfunc_dpiData_getStmt /*line :217:45*/)(d.dpiData)}
}

// SetStmt sets Stmt to data.
func (d *Data) SetStmt(s *statement) {
	func() { var _cgo0 *_Ctype_struct_dpiData = /*line :222:20*/d.dpiData; _cgo1 := /*line :222:31*/s.dpiStmt; _cgoCheckPointer(_cgo1, nil); _Cfunc_dpiData_setStmt(_cgo0, _cgo1); }()
}

// GetTime gets Time from data.
func (d *Data) GetTime() time.Time {
	if d.IsNull() {
		return time.Time{}
	}
	ts := ( /*line :230:8*/_Cfunc_dpiData_getTimestamp /*line :230:29*/)(d.dpiData)
	return time.Date(
		int(ts.year), time.Month(ts.month), int(ts.day),
		int(ts.hour), int(ts.minute), int(ts.second), int(ts.fsecond),
		timeZoneFor(ts.tzHourOffset, ts.tzMinuteOffset),
	)

}

// SetTime sets Time to data.
func (d *Data) SetTime(t time.Time) {
	_, z := t.Zone()
	( /*line :242:2*/_Cfunc_dpiData_setTimestamp /*line :242:23*/)(d.dpiData,
		 /*line :243:3*/_Ctype_int16_t /*line :243:12*/(t.Year()),  /*line :243:24*/_Ctype_uint8_t /*line :243:33*/(t.Month()),  /*line :243:46*/_Ctype_uint8_t /*line :243:55*/(t.Day()),
		 /*line :244:3*/_Ctype_uint8_t /*line :244:12*/(t.Hour()),  /*line :244:24*/_Ctype_uint8_t /*line :244:33*/(t.Minute()),  /*line :244:47*/_Ctype_uint8_t /*line :244:56*/(t.Second()),  /*line :244:70*/_Ctype_uint32_t /*line :244:80*/(t.Nanosecond()),
		 /*line :245:3*/_Ctype_int8_t /*line :245:11*/(z/3600),  /*line :245:21*/_Ctype_int8_t /*line :245:29*/((z%3600)/60),
	)
}

// GetUint64 gets data as uint64.
func (d *Data) GetUint64() uint64 {
	if d.IsNull() {
		return 0
	}
	return uint64(( /*line :254:16*/_Cfunc_dpiData_getUint64 /*line :254:34*/)(d.dpiData))
}

// SetUint64 sets data to uint64.
func (d *Data) SetUint64(u uint64) {
	( /*line :259:2*/_Cfunc_dpiData_setUint64 /*line :259:20*/)(d.dpiData,  /*line :259:33*/_Ctype_uint64_t /*line :259:43*/(u))
}

// IntervalYM holds Years and Months as interval.
type IntervalYM struct {
	Years, Months int
}

// Get returns the contents of Data.
func (d *Data) Get() interface{} {
	switch d.NativeTypeNum {
	case ( /*line :270:7*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :270:31*/):
		return d.GetBool()
	case ( /*line :272:7*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :272:29*/):
		return d.GetBytes()
	case ( /*line :274:7*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :274:30*/):
		return d.GetFloat64()
	case ( /*line :276:7*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :276:29*/):
		return d.GetFloat32()
	case ( /*line :278:7*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :278:29*/):
		return d.GetInt64()
	case ( /*line :280:7*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :280:35*/):
		return d.GetIntervalDS()
	case ( /*line :282:7*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :282:35*/):
		return d.GetIntervalYM()
	case ( /*line :284:7*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :284:27*/):
		return d.GetLob()
	case ( /*line :286:7*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :286:30*/):
		return d.GetObject()
	case ( /*line :288:7*/_Ciconst_DPI_NATIVE_TYPE_STMT /*line :288:28*/):
		return d.GetStmt()
	case ( /*line :290:7*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :290:33*/):
		return d.GetTime()
	case ( /*line :292:7*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :292:30*/):
		return d.GetUint64()
	default:
		panic(fmt.Sprintf("unknown NativeTypeNum=%d", d.NativeTypeNum))
	}
}

// Set the data.
func (d *Data) Set(v interface{}) error {
	if v == nil {
		return errors.Errorf("%s: %w", "nil type", ErrNotSupported)
	}
	if d.dpiData == nil {
		d.dpiData = & /*line :305:16*/_Ctype_dpiData /*line :305:25*/{isNull: 1}
	}
	switch x := v.(type) {
	case int32:
		d.NativeTypeNum = ( /*line :309:21*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :309:43*/)
		d.SetInt64(int64(x))
	case int64:
		d.NativeTypeNum = ( /*line :312:21*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :312:43*/)
		d.SetInt64(x)
	case uint64:
		d.NativeTypeNum = ( /*line :315:21*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :315:44*/)
		d.SetUint64(x)
	case float32:
		d.NativeTypeNum = ( /*line :318:21*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :318:43*/)
		d.SetFloat32(x)
	case float64:
		d.NativeTypeNum = ( /*line :321:21*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :321:44*/)
		d.SetFloat64(x)
	case string:
		d.NativeTypeNum = ( /*line :324:21*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :324:43*/)
		d.SetBytes([]byte(x))
	case []byte:
		d.NativeTypeNum = ( /*line :327:21*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :327:43*/)
		d.SetBytes(x)
	case time.Time:
		d.NativeTypeNum = ( /*line :330:21*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :330:47*/)
		d.SetTime(x)
	case time.Duration:
		d.NativeTypeNum = ( /*line :333:21*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_DS /*line :333:49*/)
		d.SetIntervalDS(x)
	case IntervalYM:
		d.NativeTypeNum = ( /*line :336:21*/_Ciconst_DPI_NATIVE_TYPE_INTERVAL_YM /*line :336:49*/)
		d.SetIntervalYM(x)
	case *DirectLob:
		d.NativeTypeNum = ( /*line :339:21*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :339:41*/)
		d.SetLob(x)
	case *Object:
		d.NativeTypeNum = ( /*line :342:21*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :342:44*/)
		d.ObjectType = x.ObjectType
		d.SetObject(x)
	//case *stmt:
	//d.NativeTypeNum = C.DPI_NATIVE_TYPE_STMT
	//d.SetStmt(x)
	case bool:
		d.NativeTypeNum = ( /*line :349:21*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :349:45*/)
		d.SetBool(x)
	//case rowid:
	//d.NativeTypeNum = C.DPI_NATIVE_TYPE_ROWID
	//d.SetRowid(x)
	default:
		return errors.Errorf("%T: %w", ErrNotSupported, v)
	}
	return nil
}

// IsObject returns whether the data contains an Object or not.
func (d *Data) IsObject() bool {
	return d.NativeTypeNum == ( /*line :362:28*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :362:51*/)
}

// NewData returns Data for input parameters on Object/ObjectCollection.
func (c *conn) NewData(baseType interface{}, sliceLen, bufSize int) ([]*Data, error) {
	if c == nil || c.dpiConn == nil {
		return nil, errors.New("connection is nil")
	}

	vi, err := newVarInfo(baseType, sliceLen, bufSize)
	if err != nil {
		return nil, err
	}

	_, dpiData, err := c.newVar(vi)
	if err != nil {
		return nil, err
	}

	data := make([]*Data, sliceLen)
	for i := 0; i < sliceLen; i++ {
		data[i] = &Data{dpiData: &dpiData[i], NativeTypeNum: vi.NatTyp}
	}

	return data, nil
}

func newVarInfo(baseType interface{}, sliceLen, bufSize int) (varInfo, error) {
	var vi varInfo

	switch v := baseType.(type) {
	case Lob, []Lob:
		vi.NatTyp = ( /*line :394:15*/_Ciconst_DPI_NATIVE_TYPE_LOB /*line :394:35*/)
		var isClob bool
		switch v := v.(type) {
		case Lob:
			isClob = v.IsClob
		case []Lob:
			isClob = len(v) > 0 && v[0].IsClob
		}
		if isClob {
			vi.Typ = ( /*line :403:13*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :403:34*/)
		} else {
			vi.Typ = ( /*line :405:13*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :405:34*/)
		}
	case Number, []Number:
		vi.Typ, vi.NatTyp = ( /*line :408:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :408:46*/), ( /*line :408:49*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :408:71*/)
	case int, []int, int64, []int64, sql.NullInt64, []sql.NullInt64:
		vi.Typ, vi.NatTyp = ( /*line :410:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :410:46*/), ( /*line :410:49*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :410:71*/)
	case int32, []int32:
		vi.Typ, vi.NatTyp = ( /*line :412:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_INT /*line :412:50*/), ( /*line :412:53*/_Ciconst_DPI_NATIVE_TYPE_INT64 /*line :412:75*/)
	case uint, []uint, uint64, []uint64:
		vi.Typ, vi.NatTyp = ( /*line :414:23*/_Ciconst_DPI_ORACLE_TYPE_NUMBER /*line :414:46*/), ( /*line :414:49*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :414:72*/)
	case uint32, []uint32:
		vi.Typ, vi.NatTyp = ( /*line :416:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_UINT /*line :416:51*/), ( /*line :416:54*/_Ciconst_DPI_NATIVE_TYPE_UINT64 /*line :416:77*/)
	case float32, []float32:
		vi.Typ, vi.NatTyp = ( /*line :418:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_FLOAT /*line :418:52*/), ( /*line :418:55*/_Ciconst_DPI_NATIVE_TYPE_FLOAT /*line :418:77*/)
	case float64, []float64, sql.NullFloat64, []sql.NullFloat64:
		vi.Typ, vi.NatTyp = ( /*line :420:23*/_Ciconst_DPI_ORACLE_TYPE_NATIVE_DOUBLE /*line :420:53*/), ( /*line :420:56*/_Ciconst_DPI_NATIVE_TYPE_DOUBLE /*line :420:79*/)
	case bool, []bool:
		vi.Typ, vi.NatTyp = ( /*line :422:23*/_Ciconst_DPI_ORACLE_TYPE_BOOLEAN /*line :422:47*/), ( /*line :422:50*/_Ciconst_DPI_NATIVE_TYPE_BOOLEAN /*line :422:74*/)
	case []byte, [][]byte:
		vi.Typ, vi.NatTyp = ( /*line :424:23*/_Ciconst_DPI_ORACLE_TYPE_RAW /*line :424:43*/), ( /*line :424:46*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :424:68*/)
		switch v := v.(type) {
		case []byte:
			bufSize = len(v)
		case [][]byte:
			for _, b := range v {
				if n := len(b); n > bufSize {
					bufSize = n
				}
			}
		}
	case string, []string, nil:
		vi.Typ, vi.NatTyp = ( /*line :436:23*/_Ciconst_DPI_ORACLE_TYPE_VARCHAR /*line :436:47*/), ( /*line :436:50*/_Ciconst_DPI_NATIVE_TYPE_BYTES /*line :436:72*/)
		bufSize = 32767
	case time.Time, []time.Time:
		vi.Typ, vi.NatTyp = ( /*line :439:23*/_Ciconst_DPI_ORACLE_TYPE_DATE /*line :439:44*/), ( /*line :439:47*/_Ciconst_DPI_NATIVE_TYPE_TIMESTAMP /*line :439:73*/)
	case userType, []userType:
		vi.Typ, vi.NatTyp = ( /*line :441:23*/_Ciconst_DPI_ORACLE_TYPE_OBJECT /*line :441:46*/), ( /*line :441:49*/_Ciconst_DPI_NATIVE_TYPE_OBJECT /*line :441:72*/)
		switch v := v.(type) {
		case userType:
			vi.ObjectType = v.ObjectRef().ObjectType.dpiObjectType
		case []userType:
			if len(v) > 0 {
				vi.ObjectType = v[0].ObjectRef().ObjectType.dpiObjectType
			}
		}
	default:
		return vi, errors.Errorf("unknown type %T", v)
	}

	vi.IsPLSArray = reflect.TypeOf(baseType).Kind() == reflect.Slice
	vi.SliceLen = sliceLen
	vi.BufSize = bufSize

	return vi, nil
}

func (d *Data) reset() {
	d.NativeTypeNum = 0
	d.ObjectType = ObjectType{}
	if d.dpiData == nil {
		d.dpiData = & /*line :465:16*/_Ctype_dpiData /*line :465:25*/{}
	} else {
		d.SetBytes(nil)
	}
	d.dpiData.isNull = 1
}
