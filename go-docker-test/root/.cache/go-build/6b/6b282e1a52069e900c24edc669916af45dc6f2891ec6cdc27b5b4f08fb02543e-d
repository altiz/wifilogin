// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/gopkg.in/goracle.v2@v2.24.1/lob.go:1:1
// Copyright 2017 Tamás Gulácsi
//
//
// SPDX-License-Identifier: UPL-1.0 OR Apache-2.0

package goracle

/*
#include "dpiImpl.h"
*/
import _ "unsafe"
import (
	//"fmt"
	"io"
	"unicode/utf8"
	"unsafe"

	errors "golang.org/x/xerrors"
)

// Lob is for reading/writing a LOB.
type Lob struct {
	io.Reader
	IsClob bool
}

// Hijack the underlying lob reader/writer, and
// return a DirectLob for reading/writing the lob directly.
//
// After this, the Lob is unusable!
func (lob *Lob) Hijack() (*DirectLob, error) {
	if lob == nil || lob.Reader == nil {
		return nil, errors.New("lob is nil")
	}
	lr, ok := lob.Reader.(*dpiLobReader)
	if !ok {
		return nil, errors.Errorf("Lob.Reader is %T, not *dpiLobReader", lob.Reader)
	}
	lob.Reader = nil
	return &DirectLob{conn: lr.conn, dpiLob: lr.dpiLob}, nil
}

// Scan assigns a value from a database driver.
//
// The src value will be of one of the following types:
//
//    int64
//    float64
//    bool
//    []byte
//    string
//    time.Time
//    nil - for NULL values
//
// An error should be returned if the value cannot be stored
// without loss of information.
func (dlr *dpiLobReader) Scan(src interface{}) error {
	b, ok := src.([]byte)
	if !ok {
		return errors.Errorf("cannot convert LOB to %T", src)
	}
	_ = b
	return nil
}

var _ = io.Reader((*dpiLobReader)(nil))

type dpiLobReader struct {
	*conn
	dpiLob              * /*line :70:23*/_Ctype_dpiLob /*line :70:31*/
	offset, sizePlusOne  /*line :71:22*/_Ctype_uint64_t /*line :71:32*/
	finished            bool
	IsClob              bool
}

func (dlr *dpiLobReader) Read(p []byte) (int, error) {
	if dlr == nil {
		return 0, errors.New("read on nil dpiLobReader")
	}
	if dlr.finished {
		return 0, io.EOF
	}
	if len(p) == 0 {
		return 0, nil
	}
	// For CLOB, sizePlusOne and offset counts the CHARACTERS!
	// See https://oracle.github.io/odpi/doc/public_functions/dpiLob.html dpiLob_readBytes
	if dlr.sizePlusOne == 0 {
		// never read size before
		if func() _Ctype_int{ _cgo0 := /*line :90:23*/dlr.dpiLob; var _cgo1 *_Ctype_uint64_t = /*line :90:35*/&dlr.sizePlusOne; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_getSize(_cgo0, _cgo1); }() == ( /*line :90:56*/_Ciconst_DPI_FAILURE /*line :90:68*/) {
			func() _Ctype_int{ _cgo0 := /*line :91:19*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_close(_cgo0); }()
			dlr.dpiLob = nil
			return 0, errors.Errorf("getSize: %w", dlr.getError())
		}
		dlr.sizePlusOne++
	}
	n :=  /*line :97:7*/_Ctype_uint64_t /*line :97:17*/(len(p))
	//fmt.Printf("%p.Read offset=%d sizePlusOne=%d n=%d\n", dlr.dpiLob, dlr.offset, dlr.sizePlusOne, n)
	if dlr.offset+1 >= dlr.sizePlusOne {
		return 0, io.EOF
	}
	if func() _Ctype_int{ _cgo0 := /*line :102:24*/dlr.dpiLob; var _cgo1 _Ctype_uint64_t = /*line :102:36*/dlr.offset + 1; var _cgo2 _Ctype_uint64_t = /*line :102:50*/n; var _cgo3 *_Ctype_char = /*line :102:53*/(*_Ctype_char)(unsafe.Pointer(&p[0])); var _cgo4 *_Ctype_uint64_t = /*line :102:87*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_readBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == ( /*line :102:94*/_Ciconst_DPI_FAILURE /*line :102:106*/) {
		func() _Ctype_int{ _cgo0 := /*line :103:18*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_close(_cgo0); }()
		dlr.dpiLob = nil
		err := dlr.getError()
		if dlr.finished = err.(interface{ Code() int }).Code() == 1403; dlr.finished {
			dlr.offset += n
			return int(n), io.EOF
		}
		return int(n), errors.Errorf("lob=%p offset=%d n=%d: %w", dlr.dpiLob, dlr.offset, len(p), err)
	}
	//fmt.Printf("read %d\n", n)
	if dlr.IsClob {
		dlr.offset +=  /*line :114:17*/_Ctype_uint64_t /*line :114:27*/(utf8.RuneCount(p[:n]))
	} else {
		dlr.offset += n
	}
	var err error
	if n == 0 || dlr.offset+1 >= dlr.sizePlusOne {
		func() _Ctype_int{ _cgo0 := /*line :120:18*/dlr.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_close(_cgo0); }()
		dlr.dpiLob = nil
		dlr.finished = true
		err = io.EOF
	}
	return int(n), err
}

type dpiLobWriter struct {
	*conn
	dpiLob * /*line :130:10*/_Ctype_dpiLob /*line :130:18*/
	offset  /*line :131:9*/_Ctype_uint64_t /*line :131:19*/
	opened bool
	isClob bool
}

func (dlw *dpiLobWriter) Write(p []byte) (int, error) {
	lob := dlw.dpiLob
	if !dlw.opened {
		//fmt.Printf("open %p\n", lob)
		if func() _Ctype_int{ _cgo0 := /*line :140:28*/lob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_openResource(_cgo0); }() == ( /*line :140:36*/_Ciconst_DPI_FAILURE /*line :140:48*/) {
			return 0, errors.Errorf("openResources(%p): %w", lob, dlw.getError())
		}
		dlw.opened = true
	}

	n :=  /*line :146:7*/_Ctype_uint64_t /*line :146:17*/(len(p))
	if func() _Ctype_int{ _cgo0 := /*line :147:25*/lob; var _cgo1 _Ctype_uint64_t = /*line :147:30*/dlw.offset + 1; var _cgo2 *_Ctype_char = /*line :147:44*/(*_Ctype_char)(unsafe.Pointer(&p[0])); var _cgo3 _Ctype_uint64_t = /*line :147:78*/n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_writeBytes(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :147:84*/_Ciconst_DPI_FAILURE /*line :147:96*/) {
		err := errors.Errorf("writeBytes(%p, offset=%d, data=%d): %w", lob, dlw.offset, n, dlw.getError())
		dlw.dpiLob = nil
		func() _Ctype_int{ _cgo0 := /*line :150:26*/lob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_closeResource(_cgo0); }()
		return 0, err
	}
	//fmt.Printf("written %q into %p@%d\n", p[:n], lob, dlw.offset)
	dlw.offset += n

	return int(n), nil
}

func (dlw *dpiLobWriter) Close() error {
	if dlw == nil || dlw.dpiLob == nil {
		return nil
	}
	lob := dlw.dpiLob
	dlw.dpiLob = nil
	//C.dpiLob_flushBuffer(lob)
	if func() _Ctype_int{ _cgo0 := /*line :166:28*/lob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_closeResource(_cgo0); }() == ( /*line :166:36*/_Ciconst_DPI_FAILURE /*line :166:48*/) {
		err := dlw.getError()
		if ec, ok := err.(interface{ Code() int }); ok && !dlw.opened && ec.Code() == 22289 { // cannot perform %s operation on an unopened file or LOB
			return nil
		}
		return errors.Errorf("closeResource(%p): %w", lob, err)
	}
	return nil
}

// DirectLob holds a Lob and allows direct (Read/WriteAt, not streaming Read/Write) operations on it.
type DirectLob struct {
	conn   *conn
	dpiLob * /*line :179:10*/_Ctype_dpiLob /*line :179:18*/
	opened bool
}

var _ = io.ReaderAt((*DirectLob)(nil))
var _ = io.WriterAt((*DirectLob)(nil))

// NewTempLob returns a temporary LOB as DirectLob.
func (c *conn) NewTempLob(isClob bool) (*DirectLob, error) {
	typ :=  /*line :188:9*/_Ctype_uint /*line :188:15*/(( /*line :188:16*/_Ciconst_DPI_ORACLE_TYPE_BLOB /*line :188:37*/))
	if isClob {
		typ = ( /*line :190:9*/_Ciconst_DPI_ORACLE_TYPE_CLOB /*line :190:30*/)
	}
	lob := DirectLob{conn: c}
	if func() _Ctype_int{ _cgo0 := /*line :193:26*/c.dpiConn; var _cgo1 _Ctype_dpiOracleTypeNum = /*line :193:37*/typ; _cgoBase2 := /*line :193:42*/&lob.dpiLob; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_dpiConn_newTempLob(_cgo0, _cgo1, _cgo2); }() == ( /*line :193:58*/_Ciconst_DPI_FAILURE /*line :193:70*/) {
		return nil, errors.Errorf("newTempLob: %w", c.getError())
	}
	return &lob, nil
}

// Close the Lob.
func (dl *DirectLob) Close() error {
	if !dl.opened {
		return nil
	}
	dl.opened = false
	if func() _Ctype_int{ _cgo0 := /*line :205:28*/dl.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_closeResource(_cgo0); }() == ( /*line :205:42*/_Ciconst_DPI_FAILURE /*line :205:54*/) {
		return errors.Errorf("closeResource: %w", dl.conn.getError())
	}
	return nil
}

// Size returns the size of the LOB.
func (dl *DirectLob) Size() (int64, error) {
	var n  /*line :213:8*/_Ctype_uint64_t /*line :213:18*/
	if func() _Ctype_int{ _cgo0 := /*line :214:22*/dl.dpiLob; var _cgo1 *_Ctype_uint64_t = /*line :214:33*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_getSize(_cgo0, _cgo1); }() == ( /*line :214:40*/_Ciconst_DPI_FAILURE /*line :214:52*/) {
		return int64(n), errors.Errorf("getSize: %w", dl.conn.getError())
	}
	return int64(n), nil
}

// Trim the LOB to the given size.
func (dl *DirectLob) Trim(size int64) error {
	if func() _Ctype_int{ _cgo0 := /*line :222:19*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t(size); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_trim(_cgo0, _cgo1); }() == ( /*line :222:51*/_Ciconst_DPI_FAILURE /*line :222:63*/) {
		return errors.Errorf("trim: %w", dl.conn.getError())
	}
	return nil
}

// Set the contents of the LOB to the given byte slice.
// The LOB is cleared first.
func (dl *DirectLob) Set(p []byte) error {
	if func() _Ctype_int{ _cgo0 := /*line :231:27*/dl.dpiLob; var _cgo1 *_Ctype_char = /*line :231:38*/(*_Ctype_char)(unsafe.Pointer(&p[0])); var _cgo2 _Ctype_uint64_t = _Ctype_uint64_t(len(p)); _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_setFromBytes(_cgo0, _cgo1, _cgo2); }() == ( /*line :231:95*/_Ciconst_DPI_FAILURE /*line :231:107*/) {
		return errors.Errorf("setFromBytes: %w", dl.conn.getError())
	}
	return nil
}

// ReadAt reads at most len(p) bytes into p at offset.
func (dl *DirectLob) ReadAt(p []byte, offset int64) (int, error) {
	n :=  /*line :239:7*/_Ctype_uint64_t /*line :239:17*/(len(p))
	if func() _Ctype_int{ _cgo0 := /*line :240:24*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t(offset) + 1; var _cgo2 _Ctype_uint64_t = /*line :240:57*/n; var _cgo3 *_Ctype_char = /*line :240:60*/(*_Ctype_char)(unsafe.Pointer(&p[0])); var _cgo4 *_Ctype_uint64_t = /*line :240:94*/&n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_readBytes(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }() == ( /*line :240:101*/_Ciconst_DPI_FAILURE /*line :240:113*/) {
		return int(n), errors.Errorf("readBytes: %w", dl.conn.getError())
	}
	return int(n), nil
}

// WriteAt writes p starting at offset.
func (dl *DirectLob) WriteAt(p []byte, offset int64) (int, error) {
	if !dl.opened {
		//fmt.Printf("open %p\n", lob)
		if func() _Ctype_int{ _cgo0 := /*line :250:28*/dl.dpiLob; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_openResource(_cgo0); }() == ( /*line :250:42*/_Ciconst_DPI_FAILURE /*line :250:54*/) {
			return 0, errors.Errorf("openResources(%p): %w", dl.dpiLob, dl.conn.getError())
		}
		dl.opened = true
	}

	n :=  /*line :256:7*/_Ctype_uint64_t /*line :256:17*/(len(p))
	if func() _Ctype_int{ _cgo0 := /*line :257:25*/dl.dpiLob; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t(offset) + 1; var _cgo2 *_Ctype_char = /*line :257:58*/(*_Ctype_char)(unsafe.Pointer(&p[0])); var _cgo3 _Ctype_uint64_t = /*line :257:92*/n; _cgoCheckPointer(_cgo0, nil); return _Cfunc_dpiLob_writeBytes(_cgo0, _cgo1, _cgo2, _cgo3); }() == ( /*line :257:98*/_Ciconst_DPI_FAILURE /*line :257:110*/) {
		return int(n), errors.Errorf("writeBytes: %w", dl.conn.getError())
	}
	return int(n), nil
}
